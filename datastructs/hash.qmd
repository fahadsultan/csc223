---
title: "HASHING"
toc: true
---

Hashing refers to the process of mapping data values (refered to as _keys_) to a specific location in the data structure that enables reading, writing, and searching operations to be performed far more efficiently than possible with other data structures. 

<center><img src="https://images.spiceworks.com/wp-content/uploads/2023/06/06103705/image-65-1024x580.png" style="filter:invert(100%);" width="80%"></center>


<center><img src="https://miro.medium.com/v2/resize:fit:1200/1*jszc1jvaaEedwjoru1iVPg.png" style="filter:invert(100%);" width="80%"></center>


<br/>

The transformation of a key to the corresponding value is done using a <u>Hash Function</u> and the value obtained from the hash function is called <u>Hash Code</u> or simply _hashes_. 

Hashing is used in various applications such as databases, caches, and programming languages to optimize search and retrieval operations.

## Example

Suppose we want to store string values in a data structure, say array, of size 7. We then need to map the string values to a specific index in the internal array. We can use a hash function to map the strings to a specific index in the data structure.

One simple hash function is to consider the position of each character in the string values in the English alphabet and sum them up. For example, the hash value of "abc" would be 1 + 2 + 3 = 6. The hash value of "xyz" would be 24 + 25 + 26 = 75. We can then use the modulo operator `%` to map the hash value to an index in the array.

<center><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240514124555/Mapping-Key-with-indices-of-Array.webp" style="filter:invert(100%);" width="80%"></center>

Other possible simple hash functions could have been to consider only the first or last character of the string, instead of summing all the characters. Another option could be to sum the ASCII values of the characters in the string or to use the length of the string as the hash value.

## Collisions 

If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualized that for different strings same hash value is being generated by the hash function.


For example: {“ab”, “ba”} both have the same hash value, and string {“cd”,”be”} also generate the same hash value, etc. This is known as collision and it creates problem in searching, insertion, deletion, and updating of value.

<center><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/1200px-Hash_table_4_1_1_0_0_1_0_LL.svg.png" style="filter:invert(100%)" width="60%" /></center>

<br/>

Collision in Hashing occurs when two different keys map to the same hash value. Hash collisions can be intentionally created for many hash algorithms. The probability of a hash collision depends on the size of the algorithm, the distribution of hash values and the efficiency of Hash function.

The hashing process generates a small number for a big key, so there is a possibility that two keys could produce the same value. The situation where the newly inserted key maps to an already occupied, and it must be handled using some collision handling technology.

<!-- ## Collision Handling 

There are mainly two methods to handle collision:

1. **Open Addressing**: In open addressing, all elements are stored in the hash table itself. When a new element is inserted, the hash function is computed and if the slot is already occupied, then the next slot is checked. This process continues until an empty slot is found. 

	Open Addressing has the following techniques:

	* Linear Probing: Search for an empty slot sequentially
	* Quadratic Probing: Search for an empty slot using a quadratic function
	* Double Hashing: Use a second hash function to find the next slot

<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5a/Hash_table_5_0_1_1_1_1_0_LL.svg" style="filter:invert(100%);border-width:1px;">
</center>

<br/> -->



## Load Factor

The load factor of a hash table is the ratio of the number of elements stored in the hash table to the size of the hash table. It is used to measure how full the hash table is and can affect the performance of the hash table.

The load factor is calculated as:

$$ \text{Load Factor} = \frac{\text{Number of Elements}}{\text{Size of Hash Table}} $$


A high load factor means that the hash table is full and may have more collisions, which can slow down operations. A low load factor means that the hash table is not full and may have more empty slots, which can waste memory.

The load factor is used to determine when to resize the hash table. When the load factor exceeds a certain threshold, the hash table is resized to a larger size to reduce the number of collisions and improve performance.

## Hash Set vs. Hash Map

Hashing is used to implement two common data structures: hash sets and hash maps (also known as dictionaries).

<center><img src="https://javaconceptoftheday.com/wp-content/uploads/2016/01/HashSetVsHashMap.png" style="filter:invert(100%);" width="80%"></center>

<br/>

A hash set is a data structure that stores a collection of unique elements, similar to a set in mathematics. A hash set uses a hash table to store the elements and provides fast search, insert, and delete operations.

A hash map is a data structure that stores key-value pairs, similar to a dictionary in Python. A hash map uses a hash table to store the key-value pairs and provides fast search, insert, and delete operations based on the keys.

## Analysis

The time complexity of hash table operations depends on the efficiency of the hash function and the collision resolution technique. In general, hash table operations have an average-case time complexity of O(1) for search, insert, and delete operations.

The space complexity of a hash table is O(n), where n is the number of key-value pairs stored in the table. The space complexity can vary based on the load factor and the collision resolution technique used.


