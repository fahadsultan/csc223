---
title: "Shortest Path"
toc: true
---

Path finding is the process of finding a path from a starting vertex to a target vertex in a graph. There are several algorithms for path finding, including Dijkstra's algorithm, A* search, and Floyd-Warshall algorithm.

**Inputs** to path finding algorithms typically include: a graph, a starting vertex, and a target vertex. 

**Output** is the shortest path between the starting and target vertices.

Formally, a path is a sequence of vertices in a graph such that each vertex is adjacent to the next vertex in the sequence. 

The <u>length of a path</u> is the sum of the weights of the edges between the vertices in the path.

Generally, path finding algorithms can be classified into two categories:

1. **Single-source Shortest Path Algorithms**: These algorithms find the shortest path from a single source vertex to all other vertices in the graph. Examples include Dijkstra's algorithm and Bellman-Ford algorithm.

2. **All-pairs Shortest Path Algorithms**: These algorithms find the shortest path between all pairs of vertices in the graph. Examples include Floyd-Warshall algorithm.

## Unweighted Graphs: BFS

In an unweighted graph, all edges have the same weight, typically 1.

Breadth-first search (BFS) is a graph traversal algorithm that explores all vertices at the current depth before moving to the vertices at the next depth.

### Algorithm Steps

1. Initialize a queue to store vertices to visit and a set to store visited vertices.

2. Enqueue the starting vertex into the queue and mark it as visited.

3. While the queue is not empty:
    - Dequeue a vertex from the queue.
    - For each neighbor of the dequeued vertex that has not been visited:
        - Enqueue the neighbor into the queue and mark it as visited.
        - Record the parent of the neighbor (the vertex from which it was reached).

4. Once the target vertex is reached, reconstruct the path from the starting vertex to the target vertex using the recorded parents.

<center><img src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif" width="50%" style="filter:invert(1)"></center>

The time complexity of BFS is O(V + E), where V is the number of vertices and E is the number of edges in the graph.

In case of an unweighted graph, the shortest path found by BFS is guaranteed to be the shortest path in terms of the number of edges.

## Positive Weighted Graphs: Dijkstra's Algorithm

## Dijsktra's Algorithm

Dijkstra's algorithm is a single-source shortest path algorithm that finds the shortest path from a source vertex to all other vertices in a weighted graph. 

<u>A limitation of Dijkstra's algorithm is that it does not work with negative edge weights</u>.

### Algorithm Steps

1. Initialize the distance to the source vertex as 0 and the distance to all other vertices as infinity.

2. Create a priority queue to store vertices and their distances from the source vertex.

3. While the priority queue is not empty:
    - Dequeue the vertex with the minimum distance from the priority queue.
    - For each neighbor of the dequeued vertex:
        - Calculate the distance to the neighbor through the dequeued vertex.
        - If the new distance is less than the current distance to the neighbor, update the distance and enqueue the neighbor.

<center><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" width="50%" style="filter:invert(1)"></center>

## Negative Weighted Graphs: Bellman-Ford Algorithm

Bellman-Ford algorithm is a single-source shortest path algorithm that can handle graphs with negative edge weights.

### Algorithm Steps

1. Initialize the distance to the source vertex as 0 and the distance to all other vertices as infinity.

2. 'Relax' all edges V-1 times, where V is the number of vertices in the graph.
 
    Relax an edge (u, v) means to update the distance to vertex v if the distance to vertex u plus the weight of edge (u, v) is less than the current distance to vertex v.

3. Check for negative weight cycles by relaxing all edges one more time. If any distance is updated in this step, then the graph contains a negative weight cycle.

<center><img src="https://upload.wikimedia.org/wikipedia/commons/8/8d/Bellman-Ford-example.svg" width="50%" style="filter:invert(1)"></center>

The time complexity of Bellman-Ford algorithm is O(V*E), where V is the number of vertices and E is the number of edges in the graph.

