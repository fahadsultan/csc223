---
title: "Shortest Path"
toc: true
---

Path finding is the process of finding a path from a starting vertex to a target vertex in a graph. There are several algorithms for path finding, including Dijkstra's algorithm, A* search, and Floyd-Warshall algorithm.

<center><img src="https://miro.medium.com/v2/resize:fit:1400/1*aW9WuI3Oswg0u0C9wXGK6Q.jpeg" width="70%" style="filter:invert(1)"></center>

**Inputs** to path finding algorithms typically include: a graph, a starting vertex, and a target vertex. 

**Output** is the shortest path between the starting and target vertices.

Formally, a path is a sequence of vertices in a graph such that each vertex is adjacent to the next vertex in the sequence. 

The <u>length of a path</u> is the sum of the weights of the edges between the vertices in the path.


Generally, path finding algorithms can be classified into two categories:

1. **Single-source Shortest Path Algorithms**: These algorithms find the shortest path from a single source vertex to all other vertices in the graph. Examples include Dijkstra's algorithm and Bellman-Ford algorithm.

2. **All-pairs Shortest Path Algorithms**: These algorithms find the shortest path between all pairs of vertices in the graph. Examples include Floyd-Warshall algorithm.

## BFS: unweighted graphs

In an unweighted graph, all edges have the same weight, typically 1.

In case of an unweighted graph, the shortest path found by BFS is guaranteed to be the shortest path in terms of the number of edges.

## Dijsktra's Algorithm: +ve weights

Dijkstra's algorithm is a single-source shortest path algorithm that finds the shortest path from a source vertex to all other vertices in a weighted graph. 

<u>A limitation of Dijkstra's algorithm is that it does not work with negative edge weights</u>.

The steps of Dijkstra's algorithm are as follows:

1. Initialize the distance to the source vertex as 0 and the distance to all other vertices as infinity.

2. Create a priority queue to store vertices and their distances from the source vertex.

3. While the priority queue is not empty:
    - Dequeue the vertex with the minimum distance from the priority queue.
    - For each neighbor of the dequeued vertex:
        - Calculate the distance to the neighbor through the dequeued vertex.
        - If the new distance is less than the current distance to the neighbor, update the distance and enqueue the neighbor.

<center><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" width="40%" style="filter:invert(1)"></center>

## Bellman-Ford Algorithm: -ve weights

Bellman-Ford algorithm is a single-source shortest path algorithm that can handle graphs with negative edge weights.

The steps of the Bellman-Ford algorithm are as follows:

1. Initialize the distance to the source vertex as 0 and the distance to all other vertices as infinity.

2. 'Relax' all edges V-1 times, where V is the number of vertices in the graph.
 
    Relax an edge (u, v) means to update the distance to vertex v if the distance to vertex u plus the weight of edge (u, v) is less than the current distance to vertex v.

3. Check for negative weight cycles by relaxing all edges one more time. If any distance is updated in this step, then the graph contains a negative weight cycle.

<center><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0099-spt-bellman-ford-negative-weight.gif" width="50%" style="filter:invert(1)"></center>

The time complexity of Bellman-Ford algorithm is O(V*E), where V is the number of vertices and E is the number of edges in the graph.

