---
title: Introduction
toc: true
---


# About Me

<span style="font-size: 2.0em; font-weight: bold;">
Syed Fahad Sultan ÿ≥€åÿØ ŸÅ€ÅÿØ ÿ≥ŸÑÿ∑ÿßŸÜ </span> 

**Pronunciation**:  <a href="https://en.wikipedia.org/wiki/Sayyid">Saiyyudh</a> <a href="https://en.wikipedia.org/wiki/Fahd">Fahad</a> <a href="https://en.wikipedia.org/wiki/Sultan">Sool-tahn</a>

_Just call me **‚ÄúDr. Sultan‚Äù**_ (click on the speaker for a short audio clip: [üîà](https://upload.wikimedia.org/wikipedia/commons/c/cd/LL-Q9292_%28aze%29-Azerbaijani_audiorecordings-sultan.wav))

<br/>
<center><img style="filter:invert(1)" width="80%" src="assets/name.png"></center>
<br/>

I am originally from **[Lahore, Pakistan](https://en.wikipedia.org/wiki/Lahore)** and joined **Furman University** in Fall 2022 after earning my Ph.D. in Computer Science from **State University of New York at Stony Brook**.

<br/>
<center><img width="70%" src="https://i.ibb.co/wJGFKqB/badshahi-mosque.png"></center>
<br/>


Fresh out of college, I worked as a professional video game developer for a startup that later got acquired by the Japanese gaming giant **DeNA**. During this time, I was part of the team that built **TapFish**, the top-grossing game worldwide, for two weeks in 2011, on both the App Store and Google Play.

<br/>

<table>
<tr> 
    <td> <img src="https://fahadsultan.com/csc272_f23/_images/tapfish.jpeg" alt="tapfish" height="175px"> </td>
    <td> <img src="https://fahadsultan.com/csc272_f23/_images/mobility.gif" alt="mobility" height="175px"> </td>
    <td> <img src="https://fahadsultan.com/csc272_f23/_images/neuroimaging2.jpeg" alt="neuroimaging2" height="175px"> </td>
</tr>
<tr> 
    <center><td>1. Video games development</td><td> 2. Urban Sensing </td><td> 3. Computational Neuroscience </td></center>
</tr>
</table>
<br/>

I then went on to work at **Technology for People Initiative**, an applied research lab in my where I mined social media and cell phone data for proxies of socio-economic indicators that allowed more inclusive policy-making for marginalized communities. During these years, I also dabbled in data journalism and helped organize a boot camp on using data for journalists with the support of the International Center for Journalists (ICFJ) and the Knight Foundation.



<img align="right" width="30%" src="https://i.ibb.co/j6XJkn8/Screen-Shot-2024-05-03-at-12-54-31-PM.png">


In 2015, I moved to **Mecca, Saudi Arabia** to work for the GIS Innovation Center (now Wadi Makkah). There I worked on innovative **urban sensing** techniques for better crowd control during the annual pilgrimage to the city, the largest human gathering in the world every year.

During my PhD, I worked at the intersection of **computational neuroscience, bioinformatics and machine learning**. My work focused on identifying neurological and genetic biomarkers linking type-2 diabetes with cognitive disorders such as Alzheimer's and other dementias.

I live in Travelers Rest with my wife and cat. 

<br/>
<br/>


### How to Reach Me



**Office**: Riley Hall 200-H

**Email**: fahad.sultan@furman.edu

I have an **Open door policy**. I am in my office during work hours most weekdays and my door is only closed if I am in a class or in a meeting. So please drop by. 

You can also **schedule a meeting [using this link](https://calendly.com/ssultan-dpq/)** if you want to absolutely make sure that I am available.

<center>
<img width="60%" style="filter:invert(1)" src="assets/office.png"></img>
</center>

<br/>
<br/>


## About the Course
 
Course website: **[https://fahadsultan.com/csc223](https://fahadsultan.com/csc223)**

The **[Syllabus](https://fahadsultan.com/csc223/syllabus/index.html)** is available on the course website. In particular, please make sure to read the **[Grading](https://fahadsultan.com/csc223/syllabus/grading.html)**, **[Academic Integrity](https://fahadsultan.com/csc223/syllabus/integrity.html)** and **[Textbook and other Resources](https://fahadsultan.com/csc223/syllabus/textbook.html)** sections carefully.

All of the course content will be posted on this website.

Important announcements will be made on both the course website homepage and in class. 

You are to submit assignments and exams on **[the course Moodle page](https://courses.furman.edu/course/view.php?id=18720)**. I will also upload all of your grades there.

<br/>
<br/>



### How-to knowledge > What-is knowledge

<img align="right" style="filter:invert(1)" src="https://enchantedyankee.files.wordpress.com/2012/03/chess-cheat-sheet.jpg?w=921" width="30%">

**Declarative knowledge** is knowledge about facts. It is knowledge that answers the **"What is" questions**. Most courses outside Computer Science are about declarative knowledge.  

In contrast, **Imperative knowledge** is knowledge about how to do things. It is knowledge that answers the **"How to" questions**. 

While we will spend a non-trivial amount of time in this course on declarative knowledge, the overwhelming majority of this course will focus on imperative knowledge. Your grade in this course will be determined by your ability to apply declarative and more importantly imperative knowledge to solve problems. 

<img src="https://www.justinkownacki.com/wp-content/uploads/2020/11/QueensGambit_1200.jpg" width="50%" align="right">

Research shows that there is only one way to acquire imperative knowledge: **Practice, Practice, Practice !**. Practice combined with feedback is the only way to achieve mastery.

In this course, you will be given ample opportunities to practice along with regular feedback.

<br/>
<br/>

### Assignments 

Approach assignments purely as **opportunities to learn**, prepare for exams and to prepare for your career.

<img align="right" style="filter:invert(0.87)" src="https://theteachingdelusioncom.files.wordpress.com/2021/12/practice-feedback-loop.jpg?w=1024" width="40%">

It is <u>**not worth cheating**</u> on assignments. Just come talk to me if you are struggling with an assignment. I will literally just tell you the answer. 


<u>**Written Assignments:**</u>

Written assignments are to help you build a deeper understanding of algorithms and math covered in class.  

These could simply be math problems or involve tracing algorithms and dry-runs. 

Both handwritten or typed submissions are acceptable. Submissions on Moodle. 

You should expect questions in the exams similar to assignments.

<u>**Programming Assignments:**</u>

Programming assignments are going to be posted at the start of the lab session each week and will be due by the start of the next lab session, unless otherwise specified.

<br/>

### Class Participation

Class Participation is 5\% of your grade. 

**Class Participation** is not just about attendance. It is about being engaged in the class.

**Engagement** is the key to learning. 

Ask questions, answer questions, participate in discussions.

Given the glut of information accessible online and otherwise in this day and age, **meaningful interactions with your peers and teachers is essentially why you are paying your college tuition**. 

<u>The only reason you are paying such a high tuition is to have access to the collective knowledge and wisdom of your professors and peers. 

Otherwise, you could just watch YouTube videos and read books on your own.</u>

### Professionalism

Professionalism is 5\% of your grade.

Professionalism is about how you conduct yourself in the class.

This includes, but is not limited to:

1. **Respect and Courtesy**: Being respectful and courteous to your peers and your instructor.
2. **Punctuality**: Being on time for class and for assignments.
3. **Communication**: Communicating clearly and effectively with your peers and your instructor.

### Exams 

There will be **three** exams in the course, including the final. The final exam will be cumulative. Exams constitute **60%** of your course grade.

You will be evaluated on your ability to apply knowledge to new problems and not just on your ability to retain and recall information.

The exams, more than the assignments, are going to determine your grade.

All exams are going to be cumulative, with focus on the topics covered since last exam. 

Diligent work on the homework and assignments will be rewarded here. 

<br/>

### Giant Asterisk * 

<i><u>**Everything is tentative and subject to change**</u></i>


<img style="filter:invert(1)" src="assets/complaints.jpeg" width="25%" align="right">

This is my first teaching this course. **Any and all feedback** is welcome! 

I have created an anonymous feedback poll on **Moodle**. Please use this to **anonymously** share any feedback. 
 
Share **any changes** you want me to make in the course, **at any point in the semester**. You can submit multiple times over the span of the semester.  

Think of it as a _Complaints Box_ for the course.

## ‚ùå <strike>Data Structures & Algorithms</strike> <br/>‚úÖ Complexity, Abstraction and Scalability 


The course is called **Data Structures & Algorithms**. In my opinion, a more appropriate name for the course would have been **Complexities, Abstractions and Scalability**. 

**Complexity** is the **primary challenge** we will be dealing with in this course. **Abstractions** are going to be our **primary tool** to deal with complexity. **Scalability** is the **primary goal** in this course i.e. to write code that can handle the data we have today and the data we expect to have in the future.

<hr/>

In the world of software development, **lines of code (LOC)** are often used as a metric to measure the size and complexity of a codebase. The more lines of code a project has, the larger and more intricate it is likely to be. 

How many millions of lines of code does it take to make the modern program, web service, car, or airplane possible? The figure below sheds some light on this question.

<center>
<img style="filter:invert(1)" src="https://www.visualcapitalist.com/wp-content/uploads/2017/02/1276_lines_of_code_sep2015_fb.png" width="80%">
</center>


The range is extraordinary: the average iPhone app has less than 50,000 lines of code, while Google‚Äôs entire code base is two billion lines for all services. The code needed for fighter jets, popular video game engines, and even the Large Hadron Collider falls somewhere in between the two. It‚Äôs been said that the modern smartphone has more lines of code than a passenger jet ‚Äì and that the code for a typical car has 100 million lines of code.

In fact, the lines of code for the Apollo 11 moon lander totaled just 145,000 ‚Äì and the code for the Space Shuttle was about the same. 

It‚Äôs more than what was needed to run old technologies like the Space Shuttle, a pacemaker, or even the game engine of Quake 3 ‚Äì but it‚Äôs not enough to be the driving force behind the modern software that‚Äôs used in everyday life today.

<img style="filter:invert(0.87)" src="https://computersciencewiki.org/images/e/e2/Abstract_heart.png" width="50%" align="right">

A million lines of code, if printed, would be about 18,000 pages of text. That‚Äôs 14x the length of War and Peace.

How do we then manage this complexity? A large part of the answer lies in **Abstractions**. Abstractions are ways of dividing a complex system into smaller, more manageable pieces. Each piece is a **black box** or **module** that can be used without having to know how it works internally. However, the pieces are not completely opaque. They have a well-defined interface that allows us to use them without knowing how they work internally. 


On the other hand, the amount of **Data** that we have to deal with is growing exponentially. Approximately 328.77 million terabytes of data are created each day. 

<img align="right" style="filter:invert(1)" width="50%" src="https://cdn.buttercms.com/output=f:webp/ods4p5fQVmXkFeHFP3Zx">


Here‚Äôs a selection of other user-generated internet content stats:

| Type of Media | Amount per Minute | Amount per Day |
|:---:|:---:|:---:|
| Emails sent | 231.4 million | 333.22 billion |
| Texts sent | 16 million | 24.04 billion |
| Google searches | 5.9 million | 8.5 billion |
| Snaps shared on Snapchat | 2.43 million | 3.5 billion |
| Pieces of content shared on Facebook | 1.7 million | 2.45 billion |
| Swipes on Tinder | 1.1 million | 1.58 billion |
| Hours streamed | 1 million | 1.44 billion |
| USD spent on Amazon | 443,000 | 637.92 million |
| USD sent on Venmo | 437,600 | 630.14 million |
| Tweets shared on Twitter | 347,200 | 499.97 million |
| Hours spent in Zoom meetings | 104,600 | 150.62 million |
| USD spent on DoorDash | 76,400 | 110.02 million |

For the software engineer this means writing code that can not only handle the data we have today, but also data that we expect to have in the future. In other words, we need to write code that is **scalable**.


## Six Problems of Interest

A LOT of problems in computer science can be _'reduced'_ to a very small set of fundamental problems.

In this course, we are going to focus on the six of such fundamental problems. 

1. **Search** : Given a set of data, find a particular element in the set<br/>
2. **Sort** : Given a set of data, arrange the elements in a particular order<br/>

3-6. **Create, Read, Update, Delete** (CRUD)

### 1. Search

We are concerned with the process of collecting information in a computer's memory, in such a way that the information can subsequently be recovered as quickly as possible. 

<img style="filter:invert(0.88)" src="https://53.fs1.hubspotusercontent-na1.net/hub/53/hubfs/pixta_26761468_M.jpg?width=610&height=406&name=pixta_26761468_M.jpg" width="50%" align="right">


In this course, we are going to focus on the simplest form of search: **searching for a single element in a set of data** i.e. 
how to find the data that has been stored with a given identification. For example, in a numerical application we might want to find $f(x)$, given $x$ and a table of the values of $f$; in a nonnumerical application, we might want to find the English translation of a given Russian word.

In general, we shall suppose that a set of $N$ records has been stored, and the problem is to locate the appropriate one. As in the case of sorting, we assume that each record includes a special field called its key; this terminology is especially appropriate, because many people spend a great deal of time every day searching for their keys. We generally require the $N$ keys to be distinct, so that each key uniquely identifies its record. Algorithms for searching are presented with a so-called argument, $q$, and the problem is to find which record has $q$ as its key. 

After the search is complete, two possibilities can arise: 

1. Either the search was successful, having located the unique record containing $q$; or 
2. It was unsuccessful, having determined that $q$ is nowhere to be found. 

Formally, the search problem is defined as follows: 

---

**Problem**: $\textbf{Search}$ \
**Input**: A set of $n$ keys $S$, and a query key $q$. \
**Required Output**: The location of $q$ in $S$, if present, else $-1$. 

---

Searching is the most time-consuming part of many programs, and the substitution of a good search method for a bad one often leads to a substantial increase in speed. In fact we can often arrange the data or the data structure so that searching is eliminated entirely, by ensuring that we always know just where to find the information we need. 

Efficient algorithms for searching turn out to be quite important in practice.


### 2. Sort 


Typical computer science students study the basic sorting algorithms at least three times before they graduate: first in introductory programming, then in data structures, and finally in an advanced algorithms course. 

<img style="filter:invert(0.88)" src="assets/sorting.png" width="50%" align="right">

Why is sorting worth so much attention? There are several reasons:

* Sorting is the basic building block that many other algorithms are built around. By understanding sorting, we obtain an amazing amount of power to solve other problems.

* Most of the interesting ideas used in the design of algorithms appear in the context of sorting, such as divide-and-conquer, data structures, and randomized algorithms.

* Computers have historically spent more time sorting than doing anything else. Research shows that a quarter of all computer cycles were spent sorting data [Knu98]. Sorting remains the most ubiquitous combinatorial algorithm problem in practice.

* Sorting is the most thoroughly studied problem in computer science. Literally dozens of different algorithms are known, most of which possess some particular advantage over all other algorithms in certain situations.

Formally, the sorting problem is defined as follows: 

---

**Problem**: $\textbf{Sorting}$ \
**Input**: A sequence of $n$ numbers $a_1, a_2, \dots, a_n$. \
**Required Output**: A permutation (reordering) $a_1', a_2', \dots, a_n'$ of the input sequence such that $a_1' \leq a_2' \leq \dots \leq a_n'$.

---

In this course, we will discuss sorting in reasonable detail, stressing how sorting can be applied to solving other problems. We will also also sorting as a way to introduce paradigms of algorithm design and analysis.

### 3-6. Create, Read, Update, Delete (CRUD)

**Create**: Adding a record to a database, inserting a node into a linked list, and inserting an element into a priority queue are all examples of the insert problem. Other names of this problem include: _Insert, Add, Post_

<img style="filter:invert(1)" src="assets/crud.png" width="60%" align="right">

**Read**:  Reading or accessing data is the most fundamental problem in computer science. Other names of this problem include: _Access, Get, Fetch, Retrieve_

**Update**: For each of the following problems, we are given a set of N records, each record containing a key and some associated data, and we are given a particular key K. The problem is to modify the record containing K in some way. Other names of this problem include: _Modify, Edit, Patch_ 

**Delete**:  Deleting a record from a database, deleting a node from a linked list, and deleting an element from a priority queue are all examples of the delete problem.  Other names of this problem include: _Remove, Drop_

<img align="right" src="" width="30%">

## Non-Linear Data Structures

In this course, we will also study non-linear data structures.

**Non-linear data structures** are those in which each data element can connect to more than two other data elements.

Examples of non-linear data structures include trees and graphs. 

**Trees** are a special type of graph, and have a hierarchical structure. Trees are used to represent the hierarchical relationships between data elements.

Examples of applications of trees in computer science include the representation of file systems and the structure of many data formats such as JSON, XML and HTML.



<center>
<img style="filter:invert(1)" width="60%" src="https://qph.cf2.quoracdn.net/main-qimg-cd17398a5fe73d3537af64952d78608a">
<br/><br/>
<img style="filter:invert(1)" width="60%" src="https://9infotech.weebly.com/uploads/1/7/5/2/17521169/sample-file-path_orig.png">
<br/><br/>
</center>


**Graphs** are used to represent relationships between data elements that are not hierarchical.

Examples of applications of graphs in computer science include the representation of social networks, the representation of the internet, and the representation of the structure of a computer network.

<center><img style="filter:invert(1)" width="60%" src="https://www.dotcom-monitor.com/blog/wp-content/uploads/sites/3/2020/05/CDN-Edge-Servers-e1589849154852.png"></center>


<!-- ## NP Complete problems

The **NP Complete problems** are the hardest problems in NP. They are the problems that are at least as hard as the hardest problems in NP.

## NP Hard problems -->

## P vs. NP

The **P vs. NP problem** is one of the seven **Millennium Prize Problems**. It asks whether every problem whose solution can be quickly verified by a computer can also be quickly solved by a computer.

<center><img src="https://fahadsultan.com/csc122/_images/skiena_bigo.png" width="100%" style="filter:invert(1)"></center>

The **P vs. NP problem** is one of the most important unsolved problems in computer science. It is also one of the most famous problems in computer science.

The **P vs. NP problem** is important because it has many practical implications. If P = NP, then many problems that are currently thought to be hard would become easy. For example, many problems in cryptography would become easy to solve.


<center><img src="https://images.squarespace-cdn.com/content/v1/5ffe234606e5ec7bfc57a7a3/1681789294699-11BPRAZY8DLK5HF5U506/Screenshot+2023-04-17+at+11.41.15+PM.png" width="80%" style="filter:invert(1)"></center>


The **P problems** are the problems that can be solved in polynomial time. 

The **NP problems** are the problems that can be verified in polynomial time but as of yet, cannot be solved in polynomial time.


### Traveling Salesman Problem

The **traveling salesman problem** is a problem in combinatorial optimization. It asks for the shortest possible route that visits each city exactly once and returns to the starting city.


<center><img src="https://brilliant-staff-media.s3-us-west-2.amazonaws.com/tiffany-wang/n8vrnuIV0J.png" width="60%" style="filter:invert(1)"></center>

The **traveling salesman problem** is one of the most important problems in computer science. It is used in many applications, such as vehicle routing, logistics, and manufacturing.

Other famous NP-complete problems include the **Traveling Salesman Problem**, the **Knapsack Problem**, and the **Graph Coloring Problem**.


