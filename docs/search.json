[
  {
    "objectID": "calendar.html",
    "href": "calendar.html",
    "title": "Calendar",
    "section": "",
    "text": "Calendar\n\n\n\n\n\n\nCaution\n\n\n\nPlease note that this is a tentative plan and is subject to change.\n\n\n\n\n\n#\nTOPIC\nREADING\nMEETING 1\nMEETING 2\nWRITTEN ASSIGNMENT\nPROGRAMMING ASSIGNMENT\n\n\n\n\n1\nIntroduction + Git\nPro Git\nIntro\nVersion Control\n\nLab 1\n\n\n2\nProgramming in Java\nIntro to Java Ch. 1-4\nAbstractions\nOperations + Control Flow\nWA 1\nPA 1\n\n\n3\nProgramming in Java\nInto to Java Ch. 1-4\nAbstractions 1\nAbstractions 2\n\nPA 2\n\n\n4\nBinary Trees\n\nTrees\nBinary Trees\nWA 2\nPA 3\n\n\n5\nBinary Search Trees\nAlgorithms Ch. 3\nBST 1\nBST 2\nWA3\nPA 4\n\n\n6\nHeaps\n\nArray based Representation\nExtraction + Heapify\nWA4\nPA5 + PA6\n\n\n\n\n\nMIDTERM\n\n\n\n\n\n#\nTOPIC\nREADING\nMEETING 1\nMEETING 2\nWRITTEN ASSIGNMENT\nPROGRAMMING ASSIGNMENT\n\n\n\n\n7\nGraphs 1\n\nTraversal\nDijkstra\n\nPA7\n\n\n8\nGraphs 2\n\nBellman Ford\nMinimum Spanning Tree\n\nPA8\n\n\n9\nHashmaps\n\n\n\n\n\n\n\n10\nBacktracking\n\n\n\n\n\n\n\n11\nGreedy\n\n\n\n\n\n\n\n12\nDynamic Programming\n\n\n\n\n\n\n\n\n\n\nFINAL EXAM"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "WAs/wa2.html",
    "href": "WAs/wa2.html",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "",
    "text": "Which of the following is True about the Java architecture?\n\n\nJava code is compiled into bytecode by the Java Development Kit (JDK)\nBytecode is an intermediate representation of the Java code that is executed by the Java Virtual Machine (JVM).\nBytecode is executed by the Java Virtual Machine (JVM) to produce machine code that runs on the underlying hardware.\nJRE is the Java Runtime Environment that includes the JVM and other libraries.\nAll of the above\n\nAnswer: D) All of the above\n\nJava is a:\n\n\nCompiled language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nInterpreted language: Java code is interpreted by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nBoth compiled and interpreted language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nNone of the above\n\nAnswer: A) Compiled language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\n\nJava programming can only be done in Visual Studio Code.\n\n\nTrue\nFalse\n\nAnswer: B) False\n\nJava is a statically typed language, which means:\n\n\nThe data type of a variable is determined at runtime and can change during execution.\nThe data type of a variable is determined at compile time and cannot change.\nThe data type of a variable is determined by the Java Virtual Machine (JVM) at runtime.\nThe data type of a variable is determined by the Java Development Kit (JDK) at runtime.\n\nAnswer: B) The data type of a variable is determined at compile time.\n\nWhich of the following is True about Object-Oriented Programming (OOP) in Java and Python?\n\n\nObject Oriented Programming (OOP) is supported in both Java and Python.\nPython supports Object-Oriented Programming (OOP) but is a multi-paradigm language that also supports procedural and functional programming paradigms on the same level as OOP.\nJava is said to be a pure Object-Oriented Programming (OOP) language because OOP is the primary programming paradigm in Java.\nAll of the above\n\nAnswer: D) All of the above\n\nWhich of the following is True?\n\n\nJava is a statically typed language and Python is a dynamically typed language.\nJava is a dynamically typed language and Python is a statically typed language.\nBoth Java and Python are statically typed languages.\nBoth Java and Python are dynamically typed languages.\n\nAnswer: A) Java is a statically typed language and Python is a dynamically typed language.\n\nWhich of the following best describes the difference between Java and Python? Select all that apply.\n\n\nJava is a scripting language and Python is a compiled language.\nJava is a compiled language and Python is an interpreted language.\nJava is a dynamically typed language and Python is a statically typed language.\nJava is a statically typed language and Python is a dynamically typed language.\n\nAnswer: B) Java is a compiled language and Python is an interpreted language. D) Java is a statically typed language and Python is a dynamically typed language.\n\nIn Java, every line of code must be inside a:\n\n\nMethod\nClass\nInterface\nPackage\n\nAnswer: B) Class\n\nClass name in Java must:\n\n\nStart with a lowercase letter.\nStart with an uppercase letter.\nStart with a number.\nStart with a special character.\n\nAnswer: B) Start with an uppercase letter.\n\nClass names in Java must:\n\n\nMatch the file name.\nBe different from the file name.\nBe the same as the package name.\nBe the same as the method name.\n\nAnswer: A) Match the file name.\n\nAll attributes and methods in Java classes must have:\n\n\nA return type.\nAn access modifier: public, private, or protected.\nA static keyword.\nA class keyword.\n\nAnswer: B) An access modifier: public, private, or protected.\n\nIn Java, which of the following is true for semicolons ;?\n\n\nSemicolons are used to mark the end of a block of code.\nSemicolons are used to separate statements in Java.\nSemicolons are used to define the start of a block of code.\nSemicolons are used to define the end of a method.\n\nAnswer: B) Semicolons are used to separate statements in Java.\n\nWhich of the following is True for curly braces {} in Java?\n\n\nCurly braces are used to define the start and end of a block of code.\nCurly braces are used to define the start and end of a method.\nCurly braces are used to define the start and end of a class.\nCurly braces are used to define the start and end of a loop.\nAll of the above\n\nAnswer: E) All of the above\n\npublic static void main(String[] args) is:\n\n\nA method that is executed first when a Java project is run.\nA method that is executed first when a Java class is instantiated.\nA method that is executed when a Java class is compiled\nA method that is executed when a Java class is imported\n\nAnswer: A) A method that is executed first when a Java project is run.\n\nvoid in Java is best described as:\n\n\nUsed to specify that a method does not return any value.\nSame as null in Java.\nUsed to specify that a method returns object of class the method is defined in.\nA valid data type for variables in Java.\n\nAnswer: A) Used to specify that a method does not return any value."
  },
  {
    "objectID": "WAs/wa2.html#primitive-data-types",
    "href": "WAs/wa2.html#primitive-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.1. Primitive Data Types",
    "text": "2.1. Primitive Data Types\n\nSort the following data types in Java from smallest to largest in terms of memory size:\n\n\nbyte, short, int, long\nlong, int, short, byte\nint, long, short, byte\nshort, byte, long, int\n\nAnswer: A) byte, short, int, long\n\ndouble in Java is a:\n\n\nA numeric primitive data type that stores integer numbers bigger than supported by int.\nA numeric primitive data type that stores floating-point numbers more precisely than float.\nA numeric primitive data type that stores integer numbers bigger than supported by long.\nA numeric primitive data type that stores floating-point numbers less precisely than float.\n\nAnswer: B) A numeric primitive data type that stores floating-point numbers more precisely than float.\n\nWhich of the following best describes char and String types in Java?\n\n\nchar is a primitive data type that stores a single character, while String is a reference type that stores a sequence of characters.\nchar is a reference type that stores a single character, while String is a primitive data type that stores a sequence of characters.\nchar and String are both primitive data types that store single characters.\nchar and String are both reference types that store sequences of characters.\n\nAnswer: A) char is a primitive data type that stores a single character, while String is a reference type that stores a sequence of characters.\n\nThere is no primitive data type in Java for strings like str in Python.\n\n\nTrue\nFalse\n\nAnswer: A) True\n\nConverting an int i = 4; to a long type can be done in Java using:\n\n\nlong l = (long) i;\nlong l = long(i);\nlong l = i.toLong();\nlong l = i;\n\nAnswer: A) long l = (long) i;\n\nint and Interger in Java are:\n\n\nThe same data type.\nDifferent data types.\nint is a primitive data type, and Integer is a wrapper class\nint is a wrapper class for the Integer primitive data type.\n\nAnswer: C) int is a primitive data type, and Integer is a wrapper class for the int primitive data type that allows it to be treated as an object.\n\nEvery primitive data type in Java has a corresponding wrapper class that allows\n\n\nThe primitive data type to be treated as an object.\nThe primitive data type to be used to be used in loops.\nThe primitive data type to be used as a return type in methods.\nThe primitive data type to be used in conditional statements.\n\nAnswer: A) The primitive data type to be treated as an object.\n\njava      int a = 10;     long b = 20;     float c = 30.0f;     double d = 40.0;     double result = a * b + c / d;\n\nIn the above code snippet, the data type of the result is determined by:\n\nThe data type of the variable a because it comes first.\nThe data type of the variable b because it is the largest integer.\nThe data type of the variable c because it is a floating-point number.\nThe data type of the variable d because it is most precise and the operand with the highest memory size.\n\nAnswer: D) The data type of the variable d."
  },
  {
    "objectID": "WAs/wa2.html#fixed-size-reference-data-types",
    "href": "WAs/wa2.html#fixed-size-reference-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.2. Fixed-Size Reference Data Types",
    "text": "2.2. Fixed-Size Reference Data Types\n\nThere are two types of data types in Java:\n\n\nStatic data types and dynamic data types.\nInteger data types and floating-point data types.\nPrimitive data types and reference data types.\nNone of the above\n\nAnswer: C) Primitive data types and reference data types.\n\nWhich of the following is a fixed-size reference data type in Java? Select all that apply.\n\n\nArrays\nUser-defined Classes\nStrings\nLinked Lists\n\nAnswer: A) Arrays and C) Strings\n\nWhich of the following best describes the difference between Arrays in Java and lists in Python? Select all that apply.\n\n\nArrays in Java are fixed in size, while lists in Python can grow or shrink dynamically.\nArrays in Java can store elements of different types, while lists in Python are homogeneous.\nArrays in Java are dynamically allocated, while lists in Python are statically allocated.\nArrays in Java are homogenous, while lists in Python can store elements of different types.\n\n\nWhich of the following is True about slicing in Java arrays? Select all that apply.\n\n\nJava arrays do not support slicing.\nJava arrays support slicing using the slice() method.\nJava arrays support slicing using the Arrays.copyOfRange() method.\nJava arrays support slicing using the [start:end] syntax.\n\nAnswer: C) Java arrays support slicing using the Arrays.copyOfRange() method.\n\nWhich of the following is the correct way to initialize an array of integers in Java? Select all that apply.\n\n\nint[] numbers = {10, 20, 30, 40, 50};\nint numbers[] = {10, 20, 30, 40, 50};\nint numbers[5] = {10, 20, 30, 40, 50};\nint numbers = {10, 20, 30, 40, 50};\n\nAnswer: A) int[] numbers = {10, 20, 30, 40, 50}; B) int numbers[] = {10, 20, 30, 40, 50};\n\nWhich of the following is the correct way to declare an array of five integers in Java? Select all that apply.\n\n\nint[] numbers = new int[5];\nint numbers[] = new int[5];\nint numbers[5] = new int[];\nint numbers = new int[5];\n\nAnswer: A) int[] numbers = new int[5];\nB) int numbers[] = new int[5];\n\nWhich of the following is the correct way to add values to an Array of integers in Java?\n\n\nnumbers.add(10);\nnumbers.append(20);\nnumbers.push(30);\nnumbers[0] = 40;\n\nAnswer: D) numbers[0] = 40;\n\nHow do you get the length of an array in Java?\n\n\nnumbers.size();\nnumbers.length();\nnumbers.size;\nnumbers.length;\n\nAnswer: D) numbers.length;\n\nWhich of the following is a correct way to initialize a String variable in Java? Select all that apply.\n\n\nString name = \"Alice\";\nString name = new String(\"Alice\");\nString name = 'Alice';\nString name = {\"Alice\"};\n\nAnswer: A) String name = \"Alice\"; and B) String name = new String(\"Alice\");\n\nWhich of the following is a correct way to compare two strings in Java? Select all that apply.\n\n\nname1 == name2;\nname1.equals(name2);\nname1.compare(name2);\nname1.compareTo(name2);\n\nAnswer: B) name1.equals(name2); and D) name1.compareTo(name2);\n\nWhich of the following is a correct way to concatenate two strings in Java? Select all that apply.\n\n\nname1 + name2;\nname1.concat(name2);\nname1.append(name2);\nname1.join(name2);\n\nAnswer: A) name1 + name2; and B) name1.concat(name2);\n\nStrings in Java are:\n\n\nMutable: Strings can be changed after they are created.\nImmutable: Strings cannot be changed after they are created.\nConditional: Strings can be changed as long as the new value is the same length.\nNone of the above\n\nAnswer: B) Immutable: Strings cannot be changed after they are created.\n\nConverting \"123\" of type String to an integer in Java can be done using:\n\n\nInteger.parseInt(\"123\");\nint.parse(\"123\");\nString.toInt(\"123\");\n(int) \"123\"\n\nAnswer: A) Integer.parseInt(\"123\");"
  },
  {
    "objectID": "WAs/wa2.html#dynamic-size-reference-data-types",
    "href": "WAs/wa2.html#dynamic-size-reference-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.3. Dynamic-Size Reference Data Types",
    "text": "2.3. Dynamic-Size Reference Data Types\n\nDoes Java support dynamic-size reference data types?\n\n\nYes, Java supports dynamic-size reference data types but not primitive data types and you have to import the java.util package to use them.\nNo, Java does not support dynamic-size reference data types and you must use fixed-size arrays.\n\n\nWhich of the following is true about dynamic-size reference data type in Java? Select all that apply.\n\n\nArrayList is a dynamic-size reference data type in Java and behaves analogously to Python lists.\nHashSet is a dynamic-size reference data type in Java that stores unique elements and behaves analogously to Python sets.\nHashMap is a dynamic-size reference data type in Java that stores key-value pairs and behaves analogously to Python dictionaries.\nAll of the above\n\nAnswer: D) All of the above"
  },
  {
    "objectID": "WAs/wa2.html#classes-user-defined-types",
    "href": "WAs/wa2.html#classes-user-defined-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.4. Classes: User Defined Types",
    "text": "2.4. Classes: User Defined Types\n\nstatic keyword in Java is best described as:\n\n\nUsed to specify that a method does not return any value.\nUsed to specify that a method is associated with the class rather than an instance of the class.\nUsed to specify that a method is associated with an instance of the class rather than the class itself.\nA valid data type for variables in Java.\n\nAnswer: B) Used to specify that a method is associated with the class rather than an instance of the class.\n\nfinal keyword in Java is best described as:\n\n\nUsed to specify that a variable or method is associated with the class rather than an instance of the class.\nUsed to specify that a variable or method cannot be changed or overridden.\nUsed to specify that a variable or method is associated with an instance of the class rather than the class itself.\nUsed to specify that a variable or method must never be accessed.\n\nAnswer: B) Used to specify that a variable or method cannot be changed or overridden."
  },
  {
    "objectID": "WAs/wa2.html#math-operators",
    "href": "WAs/wa2.html#math-operators",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.1. Math Operators",
    "text": "3.1. Math Operators"
  },
  {
    "objectID": "WAs/wa2.html#built-in-functions",
    "href": "WAs/wa2.html#built-in-functions",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.2. Built-in Functions",
    "text": "3.2. Built-in Functions"
  },
  {
    "objectID": "WAs/wa2.html#file-io",
    "href": "WAs/wa2.html#file-io",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.3. File I/O",
    "text": "3.3. File I/O"
  },
  {
    "objectID": "WAs/wa2.html#testing-in-java",
    "href": "WAs/wa2.html#testing-in-java",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.4. Testing in Java",
    "text": "3.4. Testing in Java"
  },
  {
    "objectID": "WAs/wa2.html#conditionals",
    "href": "WAs/wa2.html#conditionals",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.1. Conditionals",
    "text": "4.1. Conditionals"
  },
  {
    "objectID": "WAs/wa2.html#loops",
    "href": "WAs/wa2.html#loops",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.2. Loops",
    "text": "4.2. Loops"
  },
  {
    "objectID": "WAs/wa2.html#exception-handling",
    "href": "WAs/wa2.html#exception-handling",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.3. Exception Handling",
    "text": "4.3. Exception Handling\n\nConstructors in Java are defined as:\n\n\npublic void constructor()\npublic constructor()\npublic Constructor()\npublic ClassName()\n\nAnswer: D) public ClassName()\n\nWhich of the following is True about constructors in Java classes?\n\n\nA class in Java can have multiple constructors with different parameters.\nA class in Java can have multiple constructors with the same parameters.\nA class in Java can have only one constructor.\nA class in Java cannot have a constructor.\n\nAnswer: A) A class in Java can have multiple constructors with different parameters.\n\nWhich of the following is True about constructors in Java classes?\n\n\nA constructor must have the same name as the class with no return type.\nA constructor must have a different name than the class with a return type of void.\nA constructor must have a different name than the class with a return type of the class.\nA constructor must have the same name as the class with a return type of the class.\n\nAnswer: A) A constructor must have the same name as the class with no return type.\n\nAll methods in Java must have the following. Select all that apply.\n\n\nA return type\nAn access modifier: public, private, or protected\nA static keyword\nA class keyword\nA return type and B) An access modifier: public, private, or protected\n\n\nWhich of the following is True about the main method in Java?\n\n\nThe main method is required in every Java class.\nThe main method is executed first when a Java project is run.\nThe main method must have a return type of void.\nThe main method must be declared as public static void main(String[] args).\n\nAnswer: A) The main method is required in every Java class. B) The main method is executed first when a Java project is run. D) The main method must be declared as public static void main(String[] args).\n\nWhat is the keyword used for pointing to the current instance of the class in Java?\n\n\nnew\nself\nthis\nclass\n\nAnswer: C) this\n\nWhich of the following arithmetic operators is not supported in Java?\n\n\nModulus (%)\nFloor division (//)\nMultiplication (*)\nExponentiation (**)\n\nAnswer: D) Exponentiation (**) and Floor division (//) are not supported in Java.\n\nWhich of the following is the boolean and operator in Java?\n\n\n&\n&&\n^\nand\n\nAnswer: B) &&\n\nWhich of the following is true for System.out.println in Java?\n\n\nWe need to import the System class to use System.out.println.\nSystem.out.println is used to print output to the console.\nprintln is a method of the System.out class that prints a new line.\nAll of the above\n\nAnswer: D) All of the above\n\ntry and except in Python are equivalent to which of the following in Java?\n\n\ntry and catch\ntry and finally\ntry and throw\ntry and throws\n\nAnswer: A) try and catch"
  },
  {
    "objectID": "syllabus/academic_success.html",
    "href": "syllabus/academic_success.html",
    "title": "Center for Academic Success",
    "section": "",
    "text": "Center for Academic Success\nPeer Tutors are available free of charge for many classes and may be requested by dropping by CAS (LIB 002) or on the Center for Academic Success website. Tutors are typically recommended by faculty and have performed well in the class. \nThe Writing & Media Lab (WML) is staffed by student Consultants who are trained to help you improve your writing and multimodal communication skills. The consultation process is non-directive and intended to allow students to maintain ownership of their work. In addition to helping with the nuts and bolts, WML Consultants also support you in developing your own ideas thoughtfully and critically, whether you’re writing an essay or planning a video or other multimedia project. You may drop into the WML during its regular hours (LIB 002; 9 AM to 10 PM) or visit the **Writing and Media Lab website to make an appointment online.\nProfessional Academic Assistance Staff in CAS can provide students assistance with time management, study skills, and organizational skills.\nThe Writing and ESL Specialist provides professional writing support as well as support for students whose primary language is not English.",
    "crumbs": [
      "Center for Academic Success"
    ]
  },
  {
    "objectID": "syllabus/accomodations.html",
    "href": "syllabus/accomodations.html",
    "title": "Accomodations",
    "section": "",
    "text": "Accomodations\nFurman University recognizes a student with a disability as anyone whose impairment substantially limits one or more major life activity. Students may receive a variety of services including classroom accommodations such as extended time on tests, test proctoring, note-taking assistance and access to assistive technology. However, receipt of reasonable accommodations cannot guarantee success–all students are responsible for meeting academic standards. Students with a diagnosed disability may be entitled to accommodations under the Americans with Disabilities Act (ADA).\nPlease visit Student Office for Accessibility Resources for more info.",
    "crumbs": [
      "Accomodations"
    ]
  },
  {
    "objectID": "syllabus/title_9.html",
    "href": "syllabus/title_9.html",
    "title": "Nondiscrimination Policy and Sexual Misconduct",
    "section": "",
    "text": "Nondiscrimination Policy and Sexual Misconduct\nFurman University and its faculty are committed to supporting our students and seeking an environment that is free of bias, discrimination, and harassment. Furman does not unlawfully discriminate on the basis of race, color, national origin, sex, sexual orientation, gender identity, pregnancy, disability, age, religion, veteran status, or any other characteristic or status protected by applicable local, state, or federal law in admission, treatment, or access to, or employment in, its programs and activities.\nIf you have encountered any form of discrimination or harassment, including sexual misconduct (e.g. sexual assault, sexual harassment or gender-based harassment, sexual exploitation or intimidation, stalking, intimate partner violence), we encourage you to report this to the institution. If you wish to report such an incident of misconduct, you may contact Furman’s Title IX Coordinator, Melissa Nichols (Trone Center, Suite 215; Melissa.nichols@furman.edu; 864.294.2221).\nIf you would like to speak with someone who can advise you but maintain complete confidentiality, you can talk with a counselor, a professional in the Student Health Center or someone in the Office of Spiritual Life. If you speak with a faculty member, understand that as a “Responsible Employee” of the University, the faculty member MUST report to the University’s Title IX Coordinator what you share to help ensure that your safety and welfare are being addressed, consistent with the requirements of the law.\nAdditional information about Furman’s Sexual Misconduct Policy, how to report sexual misconduct and your rights can be found at the Furman Title IX Webpage. You do not have to go through the experience alone.",
    "crumbs": [
      "Nondiscrimination Policy and Sexual Misconduct"
    ]
  },
  {
    "objectID": "syllabus/about.html",
    "href": "syllabus/about.html",
    "title": "Course Description and Goals",
    "section": "",
    "text": "CSC-122 Data Structures and Algorithms\n\n\n\n\n\nCore course required for all Computer Science majors\nPre-requisite for, among others:\n\nCSC-343 Artificial Intelligence\nCSC-344 Computer Graphics and Image Processing\nCSC-348 Game Design & Development\nCSC-353 Software Engineering\nCSC-346 Operating Systems\nCSC-331 Computer Architecture\n\n\n\n\n\nThis course introduces non-linear data structures (such as hash tables, trees, and graphs) as well as advanced algorithmic paradigms (such as Backtracking, Greedy Algorithms and Dynamic Programming). Students will extensively use version control software and learn about software engineering practices.\n\n\n\n\nUnderstand and implement non-linear data structures\nUnderstand and implement advanced algorithmic paradigms\nUnderstand and apply software engineering practices\nUnderstand and apply version control software",
    "crumbs": [
      "Course Description and Goals"
    ]
  },
  {
    "objectID": "syllabus/about.html#pre-requisites",
    "href": "syllabus/about.html#pre-requisites",
    "title": "Course Description and Goals",
    "section": "",
    "text": "CSC-122 Data Structures and Algorithms",
    "crumbs": [
      "Course Description and Goals"
    ]
  },
  {
    "objectID": "syllabus/about.html#fulfills-requirements",
    "href": "syllabus/about.html#fulfills-requirements",
    "title": "Course Description and Goals",
    "section": "",
    "text": "Core course required for all Computer Science majors\nPre-requisite for, among others:\n\nCSC-343 Artificial Intelligence\nCSC-344 Computer Graphics and Image Processing\nCSC-348 Game Design & Development\nCSC-353 Software Engineering\nCSC-346 Operating Systems\nCSC-331 Computer Architecture",
    "crumbs": [
      "Course Description and Goals"
    ]
  },
  {
    "objectID": "syllabus/about.html#course-description",
    "href": "syllabus/about.html#course-description",
    "title": "Course Description and Goals",
    "section": "",
    "text": "This course introduces non-linear data structures (such as hash tables, trees, and graphs) as well as advanced algorithmic paradigms (such as Backtracking, Greedy Algorithms and Dynamic Programming). Students will extensively use version control software and learn about software engineering practices.",
    "crumbs": [
      "Course Description and Goals"
    ]
  },
  {
    "objectID": "syllabus/about.html#course-goals",
    "href": "syllabus/about.html#course-goals",
    "title": "Course Description and Goals",
    "section": "",
    "text": "Understand and implement non-linear data structures\nUnderstand and implement advanced algorithmic paradigms\nUnderstand and apply software engineering practices\nUnderstand and apply version control software",
    "crumbs": [
      "Course Description and Goals"
    ]
  },
  {
    "objectID": "syllabus/integrity.html",
    "href": "syllabus/integrity.html",
    "title": "Academic Integrity",
    "section": "",
    "text": "Academic Integrity\nAcademic Integrity standards are important to our Furman community and will be upheld in this class. Students should review the Academic Integrity Pledge and other resources available on the Academic Integrity page on the Furman website. Pay special attention to definitions of cheating, plagiarism, unacceptable collaboration, facilitating misconduct and other types of misrepresentation. All those apply in this course.\nFor programming assignments/homeworks and labs, follow the 50 foot policy in its spirit.\n\nIn this class, the grade penalty for an academic integrity violation is an F for the course. Academic Discipline procedures will be followed through the Office of the Academic Dean.",
    "crumbs": [
      "Academic Integrity"
    ]
  },
  {
    "objectID": "syllabus/grading.html",
    "href": "syllabus/grading.html",
    "title": "Grading",
    "section": "",
    "text": "Component\nPercentage\n\n\n\n\nClass Participation \\(^1\\)\n10%\n\n\nWritten Assignments\n10%\n\n\nLabs / Programming Assignments \\(^2\\)\n20%\n\n\nMidterm\n25%\n\n\nFinal (Cumulative)\n35%\n\n\n\nPreviously:\n\n\n\nComponent\nPercentage\n\n\n\n\nClass Participation \\(^1\\)\n10%\n\n\nWritten Assignments\n10%\n\n\nLabs / Programming Assignments \\(^2\\)\n20%\n\n\nExam 1\n10%\n\n\nExam 2 Midterm\n20%\n\n\nFinal (Cumulative)\n30%\n\n\n\n\\(^1\\) Details in Introduction\n\\(^2\\) Labs / Programming assignments will only be graded in-person in my office or in the lab, within 10 calendar days of them being posted.\nUse this link to schedule a time to get your assignments graded.\n\n\n\n(+/- at instructor’s discretion)\n\n\n\nLetter Grade\nRange\n\n\n\n\nA\n&gt; 90 %\n\n\nB\n80 - 90 %\n\n\nC\n70 - 80 %\n\n\nD\n60 - 70 %\n\n\nF\n&lt; 60 %\n\n\n\n\n\n\nIn order to pass this class, you must 1. Earn \\(\\geq\\) 60% of the total points 2. Attend \\(\\geq\\) 80% of the lectures and labs. 3. Submit \\(\\geq\\) 80% of written and programmming assignments. 4. Take ALL tests and final!\nIn other words, you cannot blow off an entire aspect of the course and pass this class!\nNote that this basic requirement is necessary but not sufficient to pass the class.",
    "crumbs": [
      "Grading"
    ]
  },
  {
    "objectID": "syllabus/grading.html#grade-breakdown",
    "href": "syllabus/grading.html#grade-breakdown",
    "title": "Grading",
    "section": "",
    "text": "Component\nPercentage\n\n\n\n\nClass Participation \\(^1\\)\n10%\n\n\nWritten Assignments\n10%\n\n\nLabs / Programming Assignments \\(^2\\)\n20%\n\n\nMidterm\n25%\n\n\nFinal (Cumulative)\n35%\n\n\n\nPreviously:\n\n\n\nComponent\nPercentage\n\n\n\n\nClass Participation \\(^1\\)\n10%\n\n\nWritten Assignments\n10%\n\n\nLabs / Programming Assignments \\(^2\\)\n20%\n\n\nExam 1\n10%\n\n\nExam 2 Midterm\n20%\n\n\nFinal (Cumulative)\n30%\n\n\n\n\\(^1\\) Details in Introduction\n\\(^2\\) Labs / Programming assignments will only be graded in-person in my office or in the lab, within 10 calendar days of them being posted.\nUse this link to schedule a time to get your assignments graded.",
    "crumbs": [
      "Grading"
    ]
  },
  {
    "objectID": "syllabus/grading.html#grading-scale",
    "href": "syllabus/grading.html#grading-scale",
    "title": "Grading",
    "section": "",
    "text": "(+/- at instructor’s discretion)\n\n\n\nLetter Grade\nRange\n\n\n\n\nA\n&gt; 90 %\n\n\nB\n80 - 90 %\n\n\nC\n70 - 80 %\n\n\nD\n60 - 70 %\n\n\nF\n&lt; 60 %",
    "crumbs": [
      "Grading"
    ]
  },
  {
    "objectID": "syllabus/grading.html#minimum-requirements",
    "href": "syllabus/grading.html#minimum-requirements",
    "title": "Grading",
    "section": "",
    "text": "In order to pass this class, you must 1. Earn \\(\\geq\\) 60% of the total points 2. Attend \\(\\geq\\) 80% of the lectures and labs. 3. Submit \\(\\geq\\) 80% of written and programmming assignments. 4. Take ALL tests and final!\nIn other words, you cannot blow off an entire aspect of the course and pass this class!\nNote that this basic requirement is necessary but not sufficient to pass the class.",
    "crumbs": [
      "Grading"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CSC-223: Advanced Data Structures and Software Development (Fall 2024)",
    "section": "",
    "text": "Hi! Welcome to the CSC-223 Advanced Data Structures & Software Development course website 👋🏾\nI am excited to talk code 💻, algorithms 🔄 🔀 and software engineering 📊 in this course with you!\nFrom the navigation bar on the top ☝🏾 and sidebar on the left 👈🏾, you should be able to navigate to any topic relevant to the course. If that does not help, there should also be a search icon 🔍 in the top left corner ↗️\n👇🏾 Below, you can find important links and important announcements.\n\n\n\n\n\n\nProgramming Assignment 7\n\n\n\nPA 7 is due before the midterm on Wednesday, Nov 6th, 2024 2:30 PM.\n\n\n\n\n\n\n\n\nOpen-Door Policy\n\n\n\nI have an Open-Door Policy and am in my office (Riley Hall 200-H) between 9 AM - 5 PM most weekdays. Please drop by with your questions or just to say hi!\nAlternatively, send me an email or schedule an appointment",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "datastructs/graphs.html",
    "href": "datastructs/graphs.html",
    "title": "GRAPHS",
    "section": "",
    "text": "A graph is a data structure that consists of a finite set of vertices (nodes) and a collection of edges that connect pairs of vertices. Graphs are used to model relationships between objects, such as cities connected by roads, friends connected by social networks, or dependencies between tasks in a project.\n\n\n\n\nGraph Terminology\n\nVertex (Node): A fundamental unit of a graph. It represents an entity, such as a city, person, or object.\nEdge: A connection between two vertices. It represents a relationship between the entities represented by the vertices.\nDirected Graph (Digraph): A graph in which the edges have a direction associated with them. The edges are ordered pairs of vertices.\nUndirected Graph: A graph in which the edges do not have a direction associated with them. The edges are unordered pairs of vertices.\nWeighted Graph: A graph in which each edge has an associated weight or cost. The weight can represent distance, time, cost, or any other relevant metric.\n\n\n\n\n\nPath: A sequence of vertices connected by edges. It represents a route from one vertex to another.\nCycle: A path that starts and ends at the same vertex.\nConnected Graph: A graph in which there is a path between every pair of vertices.\nDisconnected Graph: A graph in which there are vertices that are not connected by any path.\n\n\n\n \n\n\n\nDegree of a Vertex: The number of edges incident to a vertex. In a directed graph, the degree is divided into the in-degree (number of incoming edges) and out-degree (number of outgoing edges).\nAdjacency: Two vertices are adjacent if there is an edge connecting them.\nAdjacency Matrix: A matrix representation of a graph in which the rows and columns correspond to vertices, and the entries indicate whether an edge exists between the vertices.\nAdjacency List: A list representation of a graph in which each vertex has a list of adjacent vertices.\n\n\n\nGraph Representation\nThere are two common ways to represent a graph: adjacency matrix and adjacency list.",
    "crumbs": [
      "Home",
      "GRAPHS"
    ]
  },
  {
    "objectID": "datastructs/bst.html",
    "href": "datastructs/bst.html",
    "title": "Binary Search Tree",
    "section": "",
    "text": "A binary search tree (BST) is a binary tree data structure that is used to store data in a sorted order.\nThe binary search tree must at all times satisfy the binary search tree property:\nAs a result of this property, the inorder traversal of a binary search tree will always return the nodes in sorted order.",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Search Tree"
    ]
  },
  {
    "objectID": "datastructs/bst.html#operations-on-binary-search-trees",
    "href": "datastructs/bst.html#operations-on-binary-search-trees",
    "title": "Binary Search Tree",
    "section": "Operations on Binary Search Trees",
    "text": "Operations on Binary Search Trees\nAll operations on a binary search tree have a time complexity of O(h), where h is the height of the tree. h is equal to the number of levels in the tree.\nFor a balanced binary search tree, the height is O(log n), where n is the number of nodes in the tree.\nFor an unbalanced binary search tree, the height is O(n).\n\nSearch\nSearching for a node in a binary search tree is very similar to searching for a value in a sorted array.\n\n\n\n\nDepth First Search (DFS)\nA traversal algorithm that explores as far as possible along each branch before backtracking.\nDepth First Search can be implemented using the following steps:\n\nIf the tree is empty, return False.\nIf the current node is the target node, return True.\nRecursively search the left subtree.\nRecursively search the right subtree.\n\n\n\nBreadth First Search (BFS)\nA traversal algorithm that explores all the nodes at the present depth before moving on to the nodes at the next depth.\nBreadth First Search can be implemented using the following steps:\n\nIf the tree is empty, return False.\nCreate a queue and add the root node to the queue.\nWhile the queue is not empty, remove the first node from the queue.\n\nIf the current node is the target node, return True.\nAdd the left child of the current node to the queue if it exists.\nAdd the right child of the current node to the queue if it exists.\n\n\n\n\n\nInsertion\n\nAdding a new node to the tree follows the following steps:\n\nIf the tree is empty, create a new node and set it as the root of the tree.\nIf the tree is not empty\n\nCompare the value of the new node with the value of the current node.\nIf the value of the new node is less than the value of the current node, move to the left subtree.\nIf the value of the new node is greater than the value of the current node, move to the right subtree.\nRepeat steps 2.1 to 2.3 until you reach a leaf node.\n\nInsert the new node as the left child if the value of the new node is less than the value of the leaf node, or as the right child if the value of the new node is greater than the value of the leaf node.\n\n\n\n\n\nDeletion\nDeletion of a node in a binary search tree involves the following steps:\n\nIf the tree is empty, return the tree.\nIf the value of the node to be deleted is less than the value of the current node, move to the left subtree.\nIf the value of the node to be deleted is greater than the value of the current node, move to the right subtree.\nIf the value of the node to be deleted is equal to the value of the current node, delete the node.\n\nIf the node has no children, simply delete the node.\nIf the node has one child, replace the node with its child.\nIf the node has two children, find the inorder successor of the node, replace the node with the inorder successor, and delete the inorder successor.\nThe inorder successor is the smallest node in the right subtree of the node to be deleted.\n\n\n\n\nCase 1: Node to be deleted has no children \nCase 2: Node to be deleted has one child \nCase 3: Node to be deleted has two children \n\n\n\nUpdate\nUpdating a node in a binary search tree involves deleting the node and inserting a new node with the updated value.\nThe time complexity of inserting a node in a binary search tree is O(h), where h is the height of the tree.\nThe time complexity of deleting a node in a binary search tree is also O(h), where h is the height of the tree.\nTherefore, the time complexity of updating a node in a binary search tree is O(h).",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Search Tree"
    ]
  },
  {
    "objectID": "datastructs/graph_dijkstra.html",
    "href": "datastructs/graph_dijkstra.html",
    "title": "Dijkstra’s Algorithm",
    "section": "",
    "text": "Dijkstra’s algorithm is a single-source shortest path algorithm that finds the shortest path from a source vertex to all other vertices in a weighted graph.\nA limitation of Dijkstra’s algorithm is that it does not work with negative edge weights.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_dijkstra.html#how-it-works",
    "href": "datastructs/graph_dijkstra.html#how-it-works",
    "title": "Dijkstra’s Algorithm",
    "section": "How it Works",
    "text": "How it Works\nHow it works:\n\nSet initial distances for all vertices: 0 for the source vertex, and infinity for all the other.\nChoose the unvisited vertex with the shortest distance from the start to be the current vertex. So the algorithm will always start with the source as the current vertex.\nFor each of the current vertex’s unvisited neighbor vertices, calculate the distance from the source and update the distance if the new, calculated, distance is lower.\nWe are now done with the current vertex, so we mark it as visited. A visited vertex is not checked again.\nGo back to step 2 to choose a new current vertex, and keep repeating these steps until all vertices are visited.\nIn the end we are left with the shortest path from the source vertex to every other vertex in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_dijkstra.html#pseudocode",
    "href": "datastructs/graph_dijkstra.html#pseudocode",
    "title": "Dijkstra’s Algorithm",
    "section": "Pseudocode",
    "text": "Pseudocode\nThe pseudocode of Dijkstra’s algorithm are as follows:\n\nInitialize the distance to the source vertex as 0 and the distance to all other vertices as infinity.\nCreate a priority queue to store vertices and their distances from the source vertex.\nWhile the priority queue is not empty:\n\nDequeue the vertex with the minimum distance from the priority queue.\nFor each neighbor of the dequeued vertex:\n\nCalculate the distance to the neighbor through the dequeued vertex.\nIf the new distance is less than the current distance to the neighbor, update the distance and enqueue the neighbor.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_dijkstra.html#example",
    "href": "datastructs/graph_dijkstra.html#example",
    "title": "Dijkstra’s Algorithm",
    "section": "Example",
    "text": "Example\n\n\nInitial\n\n\n\n\n\nVisit Node 0\n\n\n\n\n\n\n\nVisit Node 1\n\n\n\n\n\n\n\n\nVisit Node 2\n\n\n\n\n\n\n\n\nVisit Node 3\n\n\n\n\n\n\n\n\n\n\n\nVisit Node 4\n\n\n\n\n\n\n\n\nVisit Node 5 and 6",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_dijkstra.html#implementation",
    "href": "datastructs/graph_dijkstra.html#implementation",
    "title": "Dijkstra’s Algorithm",
    "section": "Implementation",
    "text": "Implementation\nHere is an implementation of Dijkstra’s algorithm in Java:\n// Edge class to represent an edge between two nodes with a weight\nprivate static class Edge implements Comparable&lt;Edge&gt;{\n    int source;\n    int destination;\n    int weight;\n\n    public Edge(int source, int destination, int weight) {\n        this.source = source;\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    // Compare edges based on their weight\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.weight, other.weight);\n    }\n}\nimport java.util.*;\n\npublic class GraphAdjacencyList {\n    private int vertices; // Number of vertices\n    private List&lt;List&lt;Edge&gt;&gt; adjacencyList; // Adjacency list for the graph\n\n    public GraphAdjacencyList(int vertices) {\n        this.vertices = vertices;\n        adjacencyList = new ArrayList&lt;&gt;(vertices);\n        for (int i = 0; i &lt; vertices; i++) {\n            adjacencyList.add(new ArrayList&lt;&gt;());\n        }\n    }\n\n    // Add an edge to the graph\n    public void addEdge(int source, int destination, int weight) {\n        adjacencyList.get(source).add(new Edge(source, destination, weight));\n    }\n\n    // Dijkstra's algorithm implementation\n    public int[] dijkstra(int startVertex) {\n        int[] distances = new int[vertices];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[startVertex] = 0;\n\n        PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;();\n        pq.add(new Edge(-1, startVertex, 0));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int currentVertex = current.destination;\n\n            for (Edge edge : adjacencyList.get(currentVertex)) {\n                int newDist = distances[currentVertex] + edge.weight;\n                if (newDist &lt; distances[edge.destination]) {\n                    distances[edge.destination] = newDist;\n                    pq.add(new Edge(currentVertex, edge.destination, newDist));\n                }\n            }\n        }\n\n        return distances;\n    }",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_problems.html",
    "href": "datastructs/graph_problems.html",
    "title": "Traversals",
    "section": "",
    "text": "A cycle in a graph is a path that starts and ends at the same vertex. Detecting cycles in a graph is an important problem in graph theory and has many applications, such as deadlock detection in operating systems, cycle detection in resource allocation, and detecting negative cycles in financial transactions.\n\n\nTo detect cycles in a directed graph, we can use the Depth-First Search (DFS) algorithm. The idea is to maintain a boolean array visited to keep track of the vertices visited during the DFS traversal. If we encounter a vertex that is already visited and is not the parent of the current vertex, then there is a cycle in the graph."
  },
  {
    "objectID": "datastructs/graph_problems.html#cycle-detection-in-directed-graphs",
    "href": "datastructs/graph_problems.html#cycle-detection-in-directed-graphs",
    "title": "Traversals",
    "section": "",
    "text": "To detect cycles in a directed graph, we can use the Depth-First Search (DFS) algorithm. The idea is to maintain a boolean array visited to keep track of the vertices visited during the DFS traversal. If we encounter a vertex that is already visited and is not the parent of the current vertex, then there is a cycle in the graph."
  },
  {
    "objectID": "datastructs/graph_paths.html",
    "href": "datastructs/graph_paths.html",
    "title": "Shortest Path",
    "section": "",
    "text": "Path finding is the process of finding a path from a starting vertex to a target vertex in a graph. There are several algorithms for path finding, including Dijkstra’s algorithm, A* search, and Floyd-Warshall algorithm.\nInputs to path finding algorithms typically include: a graph, a starting vertex, and a target vertex.\nOutput is the shortest path between the starting and target vertices.\nFormally, a path is a sequence of vertices in a graph such that each vertex is adjacent to the next vertex in the sequence.\nThe length of a path is the sum of the weights of the edges between the vertices in the path.\nGenerally, path finding algorithms can be classified into two categories:",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path"
    ]
  },
  {
    "objectID": "datastructs/graph_paths.html#bfs-unweighted-graphs",
    "href": "datastructs/graph_paths.html#bfs-unweighted-graphs",
    "title": "Shortest Path",
    "section": "BFS: unweighted graphs",
    "text": "BFS: unweighted graphs\nIn an unweighted graph, all edges have the same weight, typically 1.\nIn case of an unweighted graph, the shortest path found by BFS is guaranteed to be the shortest path in terms of the number of edges.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path"
    ]
  },
  {
    "objectID": "datastructs/graphs_bellmanford.html",
    "href": "datastructs/graphs_bellmanford.html",
    "title": "Bellman-Ford Algorithm",
    "section": "",
    "text": "Dijkstra’s algorithm cannot handle negative weights because it assumes that once a node is reached with the shortest possible distance, there’s no need to revisit or update that distance later. This assumption holds true for graphs with only non-negative edge weights but fails when negative weights are present.\nTo handle graphs with negative weights, the Bellman-Ford algorithm is typically used. The Bellman-Ford algorithm can also be used for graphs with positive edges (both directed and undirected), like we can with Dijkstra’s algorithm, but Dijkstra’s algorithm is preferred in such cases because it is faster.\nUnlike Dijkstra’s algorithm, Bellman-Ford doesn’t rely on the greedy process of visiting each node in order of the current shortest known distance. Instead, Bellman-Ford performs multiple passes to “relax” each edge, ensuring that it correctly updates the shortest path distances even in the presence of negative weights. It also detects negative cycles, making it more robust for such cases.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graphs_bellmanford.html#pseudocode",
    "href": "datastructs/graphs_bellmanford.html#pseudocode",
    "title": "Bellman-Ford Algorithm",
    "section": "Pseudocode",
    "text": "Pseudocode\nThe Bellman-Ford algorithm is best suited to find the shortest paths in a directed graph, with one or more negative edge weights, from the source vertex to all other vertices.\nIt does so by repeatedly checking all the edges in the graph for shorter paths, as many times as there are vertices in the graph (minus 1).\nBellman-Ford algorithm is a single-source shortest path algorithm that can handle graphs with negative edge weights.\nThe steps of the Bellman-Ford algorithm are as follows:\n\nSet initial distance to zero for the source vertex, and set initial distances to infinity for all other vertices.\n‘Relax’ all edges \\(V-1\\) times, where V is the number of vertices in the graph.\nFor each edge, check if a shorter distance can be calculated, and update the distance if the calculated distance is shorter.\nRelax an edge (u, v) means to update the distance to vertex v if the distance to vertex u plus the weight of edge (u, v) is less than the current distance to vertex v.\nCheck all edges (step 2) \\(V−1\\) times. This is as many times as there are vertices (\\(V\\)), minus one.\nOptional: Check for negative cycles. This will be explained in better detail later. Check for negative weight cycles by relaxing all edges one more time. If any distance is updated in this step, then the graph contains a negative weight cycle.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graphs_bellmanford.html#negative-cycles",
    "href": "datastructs/graphs_bellmanford.html#negative-cycles",
    "title": "Bellman-Ford Algorithm",
    "section": "Negative Cycles",
    "text": "Negative Cycles\nUsing the Bellman-Ford algorithm on a graph with negative cycles will not produce a result of shortest paths because in a negative cycle we can always go one more round and get a shorter path.\nA negative cycle is a path we can follow in circles, where the sum of the edge weights is negative.\nLuckily, the Bellman-Ford algorithm can be implemented to safely detect and report the presence of negative cycles.\n\n\n\nThe time complexity of Bellman-Ford algorithm is O(V*E), where V is the number of vertices and E is the number of edges in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Shortest Path",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "objectID": "datastructs/sets.html",
    "href": "datastructs/sets.html",
    "title": "Sets",
    "section": "",
    "text": "A set is a collection of distinct elements that are stored in a way that allows for quick access and retrieval. Sets are commonly used in computer science to store unique elements and perform set operations such as union, intersection, and difference.\nSets are implemented using hash tables in many programming languages, which allows for fast search and retrieval of elements. Sets are useful for removing duplicates from a list, checking for the presence of an element, and performing set operations.\n\n\nIn Python, sets are implemented using the set data structure, which is a built-in data type that stores unique elements. Sets are unordered collections of elements, and they do not allow duplicate values.\n# Create a set\ns = set([1, 2, 3, 4, 5])\n\n# Add an element to the set\ns.add(6)\n\n# Remove an element from the set\ns.remove(3)\n\n# Check if an element is in the set\nif 4 in s:\n    print(\"Element found in set\")\n\n\n\nSets support a variety of operations, including:\n\nUnion: Combines two sets to create a new set containing all unique elements from both sets.\nIntersection: Finds the common elements between two sets and creates a new set with those elements.\nDifference: Finds the elements that are in one set but not the other and creates a new set with those elements.\nSubset: Checks if one set is a subset of another set.\nSuperset: Checks if one set is a superset of another set.\n\n\n# Create two sets\ns1 = set([1, 2, 3, 4, 5])\ns2 = set([4, 5, 6, 7, 8])\n\n# Union of two sets\nunion_set = s1.union(s2)\n\n# Intersection of two sets\nintersection_set = s1.intersection(s2)\n\n# Difference of two sets\ndifference_set = s1.difference(s2)\n\n# Check if s1 is a subset of s2\nis_subset = s1.issubset(s2)\n\n# Check if s1 is a superset of s2\nis_superset = s1.issuperset(s2)\n\n\n\nThe time complexity of set operations is similar to hash table operations, with an time complexity of O(1) for search, insert, and delete operations. The space complexity of a set is O(n), where n is the number of elements in the set.\nUnion and intersection operations have a time complexity of O(n) in the worst case, where n is the number of elements in the larger set. The space complexity of set operations depends on the size of the input sets and the implementation of the set data structure.",
    "crumbs": [
      "Home",
      "HASHMAPS",
      "Sets"
    ]
  },
  {
    "objectID": "datastructs/sets.html#sets",
    "href": "datastructs/sets.html#sets",
    "title": "Sets",
    "section": "",
    "text": "A set is a collection of distinct elements that are stored in a way that allows for quick access and retrieval. Sets are commonly used in computer science to store unique elements and perform set operations such as union, intersection, and difference.\nSets are implemented using hash tables in many programming languages, which allows for fast search and retrieval of elements. Sets are useful for removing duplicates from a list, checking for the presence of an element, and performing set operations.\n\n\nIn Python, sets are implemented using the set data structure, which is a built-in data type that stores unique elements. Sets are unordered collections of elements, and they do not allow duplicate values.\n# Create a set\ns = set([1, 2, 3, 4, 5])\n\n# Add an element to the set\ns.add(6)\n\n# Remove an element from the set\ns.remove(3)\n\n# Check if an element is in the set\nif 4 in s:\n    print(\"Element found in set\")\n\n\n\nSets support a variety of operations, including:\n\nUnion: Combines two sets to create a new set containing all unique elements from both sets.\nIntersection: Finds the common elements between two sets and creates a new set with those elements.\nDifference: Finds the elements that are in one set but not the other and creates a new set with those elements.\nSubset: Checks if one set is a subset of another set.\nSuperset: Checks if one set is a superset of another set.\n\n\n# Create two sets\ns1 = set([1, 2, 3, 4, 5])\ns2 = set([4, 5, 6, 7, 8])\n\n# Union of two sets\nunion_set = s1.union(s2)\n\n# Intersection of two sets\nintersection_set = s1.intersection(s2)\n\n# Difference of two sets\ndifference_set = s1.difference(s2)\n\n# Check if s1 is a subset of s2\nis_subset = s1.issubset(s2)\n\n# Check if s1 is a superset of s2\nis_superset = s1.issuperset(s2)\n\n\n\nThe time complexity of set operations is similar to hash table operations, with an time complexity of O(1) for search, insert, and delete operations. The space complexity of a set is O(n), where n is the number of elements in the set.\nUnion and intersection operations have a time complexity of O(n) in the worst case, where n is the number of elements in the larger set. The space complexity of set operations depends on the size of the input sets and the implementation of the set data structure.",
    "crumbs": [
      "Home",
      "HASHMAPS",
      "Sets"
    ]
  },
  {
    "objectID": "datastructs/heaps.html",
    "href": "datastructs/heaps.html",
    "title": "Heaps",
    "section": "",
    "text": "A heap is a binary tree with the following properties:\nThe heap property guarantees that the largest (in a max-heap) or smallest (in a min-heap) value is always at the root, and the tree maintains a specific order based on the type of heap.",
    "crumbs": [
      "Home",
      "TREES",
      "Heaps"
    ]
  },
  {
    "objectID": "datastructs/heaps.html#priority-queues",
    "href": "datastructs/heaps.html#priority-queues",
    "title": "Heaps",
    "section": "Priority Queues",
    "text": "Priority Queues\nA priority queue is an abstract data type, often implemented using a heap, that allows elements to be inserted and extracted based on their priority.\nThe element with the highest priority is at the root of the heap (max-heap) or the element with the lowest priority is at the root of the heap (min-heap).\nPriority queues are commonly used in algorithms and applications where elements need to be processed based on their priority, such as task scheduling, Dijkstra’s algorithm, Prim’s algorithm, Huffman coding, and more.\nNote that the terms “max-priority queue” and “min-priority queue” are used interchangeably with “max-heap” and “min-heap,” respectively, when implementing priority queues using heaps.\n\n\n\n\nPlease note that priority queue are distinct from queues or stacks, which are first-in-first-out (FIFO) and last-in-first-out (LIFO) data structures, respectively.",
    "crumbs": [
      "Home",
      "TREES",
      "Heaps"
    ]
  },
  {
    "objectID": "datastructs/heaps.html#heap-sort",
    "href": "datastructs/heaps.html#heap-sort",
    "title": "Heaps",
    "section": "Heap Sort",
    "text": "Heap Sort\nHeap sort is a sorting algorithm that uses a heap to sort an array. It involves converting the array into a heap using the heapify operation and then extracting the root element of the heap until the heap is empty.\nHeap sort involves the following steps:\n\nBuild Heap: Convert the array into a heap using the heapify operation.\nExtract Max/Min: Repeatedly extract the maximum (in a max-heap) or minimum (in a min-heap) element from the heap until the heap is empty.\nSort: The extracted elements form a sorted array.\n\n\n\n\n\n\nHeap sort has a time complexity of \\(O(\\text{n log n})\\) and is an in-place sorting algorithm with a space complexity of \\(O(1)\\).",
    "crumbs": [
      "Home",
      "TREES",
      "Heaps"
    ]
  },
  {
    "objectID": "datastructs/binarytree.html",
    "href": "datastructs/binarytree.html",
    "title": "Binary Tree",
    "section": "",
    "text": "Binary trees are a type of tree data structure in which each node has at most two children, referred to as the left child and the right child.",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Tree"
    ]
  },
  {
    "objectID": "datastructs/binarytree.html#properties-of-a-binary-tree",
    "href": "datastructs/binarytree.html#properties-of-a-binary-tree",
    "title": "Binary Tree",
    "section": "Properties of a Binary Tree",
    "text": "Properties of a Binary Tree\nTrees have the following properties:\n\nA tree with \\(n\\) nodes has \\(n-1\\) edges.\nA tree with \\(n\\) nodes has \\(n - 1\\) edges because of its fundamental properties: it is a connected and acyclic graph.\nStarting with a single node and no edges, each additional node requires exactly one edge to connect it to the existing tree, ensuring connectivity without forming cycles. This process continues as the tree grows, with each new node adding exactly one edge. As a result, a tree with \\(n\\) nodes will always have \\(n - 1\\) edges.\n\n\n\nNodes (\\(n\\))\nEdges (\\(n-1\\))\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n2\n\n\n4\n3\n\n\n…\n…\n\n\nn\nn-1\n\n\n\nThis can also be proven by induction, where adding one node to a tree with \\(k\\) nodes (and \\(k - 1\\) edges) leads to \\(k\\) edges.\n\n\n\n\nThe maximum number of nodes at level \\(l\\) of a binary tree is \\(2^l\\)\nHere level is the number of edges from the root to the node. The level of the root is \\(0\\).\n\n\n\nLevel (\\(l\\))\nMaximum Nodes\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n4\n\n\n3\n8\n\n\n…\n…\n\n\n\\(l\\)\n\\(2^l\\)\n\n\n\nEach level of the tree doubles the number of nodes from the previous level. The root node is at level 0, and each subsequent level has twice as many nodes as the previous level. Therefore, the maximum number of nodes at level \\(l\\) is \\(2^l\\).\n\n\n\n\nA tree with height \\(h\\) has at most \\(2^{h+1} - 1\\) nodes.\nEach level of the tree doubles the number of nodes from the previous level. The root node is at level 0, and each subsequent level has twice as many nodes as the previous level. Therefore, the total number of nodes in a binary tree of height h is the sum of the nodes at each level, which is given by the formula \\(2^0 + 2^1 + ... + 2^(h-1) = 2^{h+1} -1\\) .\n\n\n\nHeight (\\(h\\))\nMaximum Nodes\n\n\n\n\n0\n1\n\n\n1\n3\n\n\n2\n7\n\n\n3\n15\n\n\n…\n…\n\n\n\\(h\\)\n\\(2^{h+1} - 1\\)\n\n\n\nSome textbooks count the height of a tree as the number of nodes on the longest path from the root to a leaf node. In that case, the maximum number of nodes in a tree of height h is \\(2^h - 1\\) .\n\n\n\n\nThe height of a binary tree with \\(n\\) nodes is \\(log_2(n+1) - 1\\).\nThe height of a binary tree with \\(n\\) nodes is \\(log(n+1) - 1\\) . This formula calculates the height of a binary tree based on the number of nodes it contains. The height of a binary tree is the length of the longest path from the root to a leaf node. By using the formula \\(log(n+1) - 1\\) , we can determine the height of a binary tree given the number of nodes it contains.\n\n\n\nNodes (\\(n\\))\nHeight\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n1\n\n\n4\n2\n\n\n…\n…\n\n\nn\n\\(log_2(n+1) - 1\\)\n\n\n\nSome textbooks count the height of a tree as the number of nodes on the longest path from the root to a leaf node. In that case, the height of a binary tree with \\(n\\) nodes is \\(log_2(n) + 1\\) .",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Tree"
    ]
  },
  {
    "objectID": "datastructs/binarytree.html#traversals",
    "href": "datastructs/binarytree.html#traversals",
    "title": "Binary Tree",
    "section": "Traversals",
    "text": "Traversals\nTraversal is the process of visiting each node in the tree in a specific order.\nThere are two main types of tree traversal:\n\nBreadth-First Traversal (BFS): A traversal algorithm that explores all the nodes at the present depth before moving on to the nodes at the next depth.\n\nBreadth-first traversal is also known as level-order traversal.\n\nDepth-First Traversal (DFS): A traversal algorithm that explores as far as possible along each branch before backtracking.\n\nDepth-first traversal includes three types of traversals: preorder, inorder, and postorder.\n\n\n\n\n\n\n\n\n\nLevel Order Traversal (Breath-First Traversal)\nLevel-order traversal is a breadth-first search (BFS) algorithm that visits all the nodes at the present depth before moving on to the nodes at the next depth.\n\n \n\n\nPsuedocode for level order traversal:\n\n\nCreate a queue and enqueue the root node.\nWhile the queue is not empty:\n2.1. Dequeue a node from the queue.\n2.2. Process the node (e.g., print its value).\n2.3. Enqueue the left child of the node if it exists.\n2.4. Enqueue the right child of the node if it exists.\n\n\n\nThe time complexity of level order traversal is \\(O(n)\\), where \\(n\\) is the number of nodes in the binary tree.\nThe space complexity of level order traversal is \\(O(n)\\), where \\(n\\) is the number of nodes in the binary tree.\n\n\n\nPreorder Traversal (DFS: Root-Left-Right)\n\nVisit the root node first, then recursively do a preorder traversal of the left subtree, followed by a preorder traversal of the right subtree.\nThe preorder traversal of a binary tree is a depth-first traversal that visits the root node first, followed by the left subtree and then the right subtree.\nThe pseudocode for preorder traversal is as follows:\n\n\nVisit the root node.\nRecursively do a preorder traversal of the left subtree.\nRecursively do a preorder traversal of the right subtree.\n\n\n\n \n\n\nPreorder traversal has the following applications:\n\nExpression Tree: Preorder traversal is used to convert an infix expression to a prefix expression (also known as Polish notation). e.g., A + B to + A B. Prefix expressions are easier to evaluate using a stack-based algorithm.\nClone a Tree: Preorder traversal is used to clone a binary tree. This is because the root node is visited first, making it easy to create a copy of the tree and connecting the left and right subtrees.\n\n\n\n\nIn-order Traversal (DFS: Left-Root-Right)\n\nIn-order traversal is a depth-first traversal that visits the left subtree first, followed by the root node, and then the right subtree.\n\n \n\n\nThe pseudocode for in-order traversal is as follows:\n\n\nRecursively do an in-order traversal of the left subtree.\nVisit the root node.\nRecursively do an in-order traversal of the right subtree.\n\n\nIn-order traversal has the following applications:\n\nBinary Search Tree (BST): In-order traversal of a BST results in a sorted list of elements. This property is used to find the k-th smallest element in a BST.\nPostfix Expression and Evaluation: In-order traversal is used to convert an infix expression to a postfix expression (also known as Reverse Polish notation). e.g., A + B to A B +. Postfix expressions are easier to evaluate using a stack-based algorithm.\n\n\n\n\nPost-order Traversal (DFS: Left-Right-Root)\n Recursively do a postorder traversal of the left subtree, followed by a postorder traversal of the right subtree, and then visit the root node.\n\n \n\n\nThe pseudocode for postorder traversal is as follows:\n\n\nRecursively do a postorder traversal of the left subtree.\nRecursively do a postorder traversal of the right subtree.\nVisit the root node.\n\n\nPostorder traversal has the following applications:\n\nExpression Tree: Postorder traversal is used to convert an infix expression to a postfix expression (also known as Reverse Polish notation). e.g., A + B to A B +. Postfix expressions are easier to evaluate using a stack-based algorithm.\nDelete a Tree: Postorder traversal is used to delete a binary tree. This is because the root node is visited last, making it easy to delete the tree from the leaves up to the root.\n\nPostorder traversal is commonly used in expression trees to evaluate expressions.",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Tree"
    ]
  },
  {
    "objectID": "datastructs/binarytree.html#operations",
    "href": "datastructs/binarytree.html#operations",
    "title": "Binary Tree",
    "section": "Operations",
    "text": "Operations\n\nInsertion\nInsertion is the process of adding a new node to the binary tree. The new node is inserted based on the value of the node and the properties of the binary tree.\nThe pseudocode for inserting a node in a binary tree that is not a binary search tree is as follows:\n\n\nCreate a new node with the given value.\nIf the root is null, set the new node as the root.\nElse, perform a level order traversal to find the first node that has an empty left or right child.\nInsert the new node as the left child if the left child is empty, otherwise insert it as the right child.\n\n\nThe time complexity of inserting a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.\nThe space complexity of inserting a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.\n\n\nDeletion\nDeletion is the process of removing a node from the binary tree. The node to be deleted is removed based on the value of the node and the properties of the binary tree.\nThe pseudocode for deleting a node in a binary tree is as follows:\n\n\nFind the node to be deleted using a level order traversal or any other traversal method.\nIf the node has no children, simply remove the node.\nIf the node has one child, replace the node with its child.\nIf the node has two children, find the inorder successor or predecessor of the node.\nReplace the node with the inorder successor or predecessor.\n\n\nThe time complexity of deleting a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.\nThe space complexity of deleting a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.\n\n\nSearching\nSearching is the process of finding a specific node in the binary tree based on its value.\nThe pseudocode for searching a node in a binary tree is as follows:\n\n\nPerform a level order traversal or any other traversal method to search for the node.\nIf the node is found, return the node.\nIf the node is not found, return null.\n\n\nThe time complexity of searching for a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.\nThe space complexity of searching for a node in a binary tree is \\(O(n)\\) in the worst case, where \\(n\\) is the number of nodes in the binary tree.",
    "crumbs": [
      "Home",
      "TREES",
      "Binary Tree"
    ]
  },
  {
    "objectID": "basics/data.html",
    "href": "basics/data.html",
    "title": "Primitive Data Types",
    "section": "",
    "text": "The atomic indivisible unit of data in computer programming is called a value.\nValues are the most basic things that a computer program manipulates or calculates.\n\nFor example, the number 42 is a value. So is \"Hello World!\".\n\nEach value belongs to a type.\nThe type of a value determines its interpretation by the computer and the operations that can be performed on it.\n\nFor example, the value 42 is of type int (short for integer) and the value \"Hello World!\" is of type str (short for string, so-called because it contains a string of letters).\n\nIn Java, every value has a type, and every type is defined by the Java programming language.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Primitive Data Types"
    ]
  },
  {
    "objectID": "basics/data.html#values-and-types",
    "href": "basics/data.html#values-and-types",
    "title": "Primitive Data Types",
    "section": "",
    "text": "The atomic indivisible unit of data in computer programming is called a value.\nValues are the most basic things that a computer program manipulates or calculates.\n\nFor example, the number 42 is a value. So is \"Hello World!\".\n\nEach value belongs to a type.\nThe type of a value determines its interpretation by the computer and the operations that can be performed on it.\n\nFor example, the value 42 is of type int (short for integer) and the value \"Hello World!\" is of type str (short for string, so-called because it contains a string of letters).\n\nIn Java, every value has a type, and every type is defined by the Java programming language.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Primitive Data Types"
    ]
  },
  {
    "objectID": "basics/data.html#primitive-data-types",
    "href": "basics/data.html#primitive-data-types",
    "title": "Primitive Data Types",
    "section": "Primitive Data Types",
    "text": "Primitive Data Types\nJava comes with the following built-in numeric data types:\n\nbyte: 8-bit signed integer. Range: -128 to 127.\nshort: 16-bit signed integer. Range: -32,768 to 32,767.\nint: 32-bit signed integer. Range: -2,147,483,648 to 2,147,483,647.\nlong: 64-bit signed integer. Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.\nfloat: 32-bit floating point number.\ndouble: 64-bit floating point number.\n\nOther primitive data types include:\n\nboolean: Represents true or false values.\nchar: Represents a single 16-bit Unicode character.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Primitive Data Types"
    ]
  },
  {
    "objectID": "basics/data.html#comparison-with-python",
    "href": "basics/data.html#comparison-with-python",
    "title": "Primitive Data Types",
    "section": "Comparison with Python",
    "text": "Comparison with Python\n\nPrimitive Data Types vs. Objects\n\nJava has a clear distinction between primitive data types (e.g., int, char, float, boolean) and objects. Primitive data types in Java are not objects and are stored directly in memory. They are more efficient but have fewer capabilities compared to objects.\nPython does not have primitive data types in the same way Java does. In Python, everything is an object, including what Java would consider primitives like integers and floats. This means even simple data types in Python have methods and are more versatile, though potentially less efficient in terms of memory.\n\n\n\nWrappers and Autoboxing\nJava has wrapper classes for each primitive type (e.g., Integer for int, Float for float). These wrappers allow primitive values to be treated as objects when necessary. Java also supports autoboxing, which automatically converts between primitives and their corresponding wrapper types.\nIn Python, since everything is an object, there is no need for separate wrapper classes or autoboxing.\n\n\nFixed-Size Memory Allocation\nJava uses fixed-size memory allocation for primitive types, which makes memory usage predictable and efficient. For example, an int always uses 4 bytes, a float uses 4 bytes, etc.\nIn contrast, Python’s objects (including what would be primitives in Java) are dynamically allocated, meaning their memory size can vary. Python integers and floats use more memory than their Java counterparts because they are objects and include metadata.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Primitive Data Types"
    ]
  },
  {
    "objectID": "basics/data.html#type-conversion",
    "href": "basics/data.html#type-conversion",
    "title": "Primitive Data Types",
    "section": "Type Conversion",
    "text": "Type Conversion\nIn Java, there are two types of type conversion:\n\nAutomatic Type Conversion: Java supports automatic type conversion when values of different types are combined in an expression. This is known as type promotion.\nExplicit Type Conversion (Type Casting): Java also supports explicit type conversion, known as type casting, which allows you to convert a value from one type to another.\n\n\nAutomatic Type Conversion (Type Promotion)\n\nWhen values of different types are combined in an expression, Java automatically promotes the values to a common type.\nThe rules for type promotion are as follows:\n\n\nIf one of the values is a double, the other value is converted to a double.\nIf one of the values is a float, the other value is converted to a float.\nIf one of the values is a long, the other value is converted to a long.\nOtherwise, both values are converted to an int.\n\nFor example:\nint a = 10;\nlong b = 20;\nfloat c = 30.0f;\ndouble d = 40.0;\n\ndouble result = a * b + c / d;\nIn this example, the int value a is promoted to a long, the float value c is promoted to a double, and the result is a double.\nIn other words, the data type of the result is determined by the data type of the most precise or the operand with the highest memory size.\n\n\nExplicit Type Conversion (Type Casting)\n\nJava allows you to explicitly convert a value from one type to another using type casting.\nType casting is done by placing the desired type in parentheses before the value to be converted.\n\nFor example:\nint a = 10;\nlong b = (long) a;\nIn this example, the int value a is explicitly cast to a long.\n\nType casting can result in data loss if the value being converted cannot be represented in the target type.\n\nFor example:\nint a = 1000;\nbyte b = (byte) a;\nIn this example, the int value a is cast to a byte. Since a byte can only represent values from -128 to 127, the result is -24, which is the remainder of 1000 divided by 256.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Primitive Data Types"
    ]
  },
  {
    "objectID": "basics/abstractions/oop1.html",
    "href": "basics/abstractions/oop1.html",
    "title": "User-defined Types",
    "section": "",
    "text": "Most modern programming languages provide a way to define new data types through the use of classes.\nA particular class essentially defines a new user-defined data type detailing how a particular kind of data is going to be structured and how it can be manipulated.\nA class therefore, at its essence, is a blueprint for creating objects (of that class). An object is an instance of a class, similar to how 7 is an instance of the int class and “Hello World!” is an instance of the str class."
  },
  {
    "objectID": "basics/abstractions/oop1.html#class-keyword",
    "href": "basics/abstractions/oop1.html#class-keyword",
    "title": "User-defined Types",
    "section": "class keyword",
    "text": "class keyword\n\nConsider the concept of a Point in euclidean space.\nIn two dimensions, a point is two numbers (coordinates) that are treated collectively as a single object. In mathematical notation, points are often written in parentheses with a comma separating the coordinates. For example, (0, 0) represents the origin, and (x, y) represents the point \\(x\\) units to the right and \\(y\\) units up from the origin.\nA natural way to represent a point in Python is with two numeric values. The question, then, is how to group these two values into a compound object. The quick and dirty solution is to use a list or tuple, and for some applications that might be the best choice.\nAn alternative is to define a new user-defined compound type, also called a class. This approach involves a bit more effort, but it has advantages that will be apparent soon.\nA class definition looks like this:\n\nclass Point:\n    \"\"\"Represents a point in 2-D space.\"\"\"\n    pass\nclass Point {\n    // instance variables\n    double x;\n    double y;\n}\nClass definitions can appear anywhere in a program, but they are usually near the beginning (after the import statements). The syntax rules for a class definition are the same as for other compound statements. There is a header which begins with the keyword, class, followed by the name of the class, and ending with a colon.\nThis definition creates a new class called Point. The pass statement has no effect; it is only necessary because a compound statement must have something in its body. A docstring could serve the same purpose:\n\nclass Point:\n    \"Point class for storing mathematical points.\"\n    pass\n\nBy creating the Point class, we created a new type, also called Point. The members of this type are called instances of the type or objects. Creating a new instance is called instantiation, and is accomplished by calling the class. Classes, like functions, are callable, and we instantiate a Point object by calling the Point class:\n\ntype(Point)\n\n\np = Point()\ntype(p)\n\nThe variable p is assigned a reference to a new Point object.\nIt may be helpful to think of a class as a factory for making objects, so our Point class is a factory for making points. The class itself isn’t an instance of a point, but it contains the machinary to make point instances."
  },
  {
    "objectID": "basics/abstractions/oop1.html#dot-.-operator",
    "href": "basics/abstractions/oop1.html#dot-.-operator",
    "title": "User-defined Types",
    "section": "Dot . operator",
    "text": "Dot . operator\nThe . operator is used to access the attributes and methods of a class.\nThe dot operator is the primary means of interaction with the objects of a class. It is used to:\n\naccess the values of attributes\nassign values to attributes\nmodify attributes values\ncall the methods of the class\n\nExamples of the use of the dot operator are given in following sections.\n\n\n\n\n\n```ovtniosy https://i.ibb.co/YbpDxmC/oop-hierarchy.png\n\n\n\n\nname: oop-hierarchy\n\n\nwidth: 100%\n\n\nalign: center\n\n\n\nClass definitions in Python are comprised primarily of attributes and methods. There are two types of attributes: instance attributes and class attributes. There are three types of methods: instance methods, class methods, and static methods.\n\n## Attributes\n\nLike real world objects, object instances have both form and function. The form consists of data elements contained within the instance. These data elements are called **attributes** (also known as _variables_ or _properties_). \n\nThere are two types of data attributes in Python:\n\n1. **Instance attributes / variables** are attributes that are unique to each instance. They are defined inside the constructor method `__init__` and are prefixed with `self` keyword.\n\n2. **Class attributes / variables** are attributes that have the same value for all class instances. We define class attributes outside all the methods, usually they are placed at the top, right below the class header.\n\n&lt;center&gt;&lt;img src=\"https://miro.medium.com/v2/resize:fit:2000/1*pGmNqM1bvCZexV8rskqIKg.png\" width=\"70%\"&gt;&lt;/center&gt;\n\n&lt;br&gt;&lt;br&gt;\n\n### Instance attributes\n\nThe attributes of an object are also called **instance variables** because they are associated with a particular instance of the class. These variables are not shared by all instances of the class, and they are not defined until the instance is created.\n\nWe can add new data elements to an instance using **dot operator**:\n\n::: {#cell-10 .cell}\n``` {.python .cell-code}\np.x = 3\np.y = 4\n:::\nThis syntax is similar to the syntax for selecting a variable from a module, such as list.append or string.lower. In this case the attribute we are selecting is a data item from an instance.\nThe following state diagram shows the result of these assignments:\n \nThe variable p refers to a Point object, which contains two attributes. Each attribute refers to a number.\nWe can read the value of an attribute using the same syntax:\n\nprint(p.y)\nx = p.x\nprint(x)\n\nThe expression p.x means, “Go to the object p refers to and get the value of x”. In this case, we assign that value to a variable named x.\nNote that there is no conflict between the variable x and the attribute x. The purpose of dot operator is to identify which variable you are referring to unambiguously.\nYou can use dot operator as part of any expression, so the following statements are legal:\n\nprint('(%d, %d)' % (p.x, p.y))\ndistance_squared = p.x * p.x + p.y * p.y\n\nThe first line outputs (3, 4); the second line calculates the value 25.\nNow that we have defined a new custom type, we can create instances of that type and manipulate them as we would an object of any native type. For example, you can pass objects of custom type as an argument to a function in the usual way:\ndef print_point(p):\n    print('(%s, %s)' % (str(p.x), str(p.y)))\nprint_point takes a point as an argument and displays it in the standard format. If you call print_point(p) with point p as defined previously, the output is (3, 4).\n\n\n\n\nClass Attributes\nNot all attributes are instance attributes. Some attributes are shared by all instances of a class. These attributes are called class attributes.\nClass attributes are defined within the class definition but outside any of the class’s methods. They are not tied to any particular instance of the class, but rather are shared by all instances of the class.\nFor example, in the Point class, we could add a class attribute to keep track of how many points have been created. We’ll call this class attribute n:\nclass Point:\n    n = 0\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n        Point.n += 1\nThe n attribute is created when the Point class is defined, and it is accessed using dot operator. The following code demonstrates how the n attribute is used:\np1 = Point()\nprint(p1.n) # 1\np2 = Point()\nprint(p2.n) # 2\nThe n attribute is shared by all instances of the Point class. Any changes made to the n attribute are reflected in all instances of the class."
  },
  {
    "objectID": "basics/abstractions/oop1.html#methods",
    "href": "basics/abstractions/oop1.html#methods",
    "title": "User-defined Types",
    "section": "Methods",
    "text": "Methods\nThe second part of the class definition is a suite of methods. A method is a function that is associated with a particular class . As examples below show, the syntax for defining a method is the same as for defining a function.\n\n\n\n\n\nInstance Methods\nInstance methods are defined inside the body of the class definition. They are used to perform operations and manipulate the instance attributes of our objects. The vast majority of the methods in a class are instance methods.\nThe first input to all instance methods is self, which is a reference to the specific instance (object) of the class on which the method is called.\n\nself\nThe self parameter is a reference to the instance of the class. It is used to access variables that belong to the class. It does not have to be named self, you can call it whatever you like, but it has to be the first parameter of any function in the class.\nWhen you create a new instance of the class, Python automatically determines what self is (the instance of the class) and passes it to the __init__ method.\n\n\n__init__\nSince our Point class is intended to represent two dimensional mathematical points, ALL point instances ought to have x and y attributes, but that is not yet so with our Point objects.\n\np2 = Point()\np2.x\n\nTo solve this problem we add an initialization method to our class.\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\nA method behaves like a function but it is part of an object. Like a data attribute it is accessed using dot notation. The initialization method is called automatically when the class is called.\nLet’s add another method, distance_from_origin, to see better how methods work:\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def distance_from_origin(self):\n        return ((self.x ** 2) + (self.y ** 2)) ** 0.5\nLet’s create a few point instances, look at their attributes, and call our new method on them:\n&gt;&gt;&gt; p = Point(3, 4)\n&gt;&gt;&gt; p.x\n3\n&gt;&gt;&gt; p.y\n4\n&gt;&gt;&gt; p.distance_from_origin()\n5.0\n&gt;&gt;&gt; q = Point(5, 12)\n&gt;&gt;&gt; q.x\n5\n&gt;&gt;&gt; q.y\n12\n&gt;&gt;&gt; q.distance_from_origin()\n13.0\n&gt;&gt;&gt; r = Point()\n&gt;&gt;&gt; r.x\n0\n&gt;&gt;&gt; r.y\n0\n&gt;&gt;&gt; r.distance_from_origin()\n0.0\nWhen defining a method, the first parameter refers to the instance being created. It is customary to name this parameter self. In the example session above, the self parameter refers to the instances p, q, and r respectively.\n\n\nGetters and Setters\nIn general it is considered bad practice to access and modify the attributes of an object directly.\nInstead, it is better to use getter and setter methods to access and modify the attributes of an object.\nA getter method is a method that returns the value of an attribute of an object. A setter method is a method that sets the value of an attribute of an object.\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def get_x(self):\n        return self.x\n\n    def set_x(self, x):\n        self.x = x\n\n    def get_y(self):\n        return self.y\n\n    def set_y(self, y):\n        self.y = y\nThe get_x and get_y methods are getter methods for the x and y attributes respectively. The set_x and set_y methods are setter methods for the x and y attributes respectively.\nThe following code demonstrates how to use the getter and setter methods:\n\np = Point(3, 4)\nprint(\"p.x: \", p.get_x())\nprint(\"p.y: \", p.get_y())\n\np.set_x(100)\np.set_y(200)\nprint(\"p.x: \", p.get_x())\nprint(\"p.y: \", p.get_y())\n\n\n\n\nClass Methods\nA class method is a method that is bound to the class and not the object of the class. They have the access to the state of the class as it takes a class parameter that points to the class and not the object instance.\nThey can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances.\nClass methods are defined using the @classmethod decorator. They take a cls parameter that points to the class and not the object instance.\nclass Point:\n    n = 0\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n        Point.n += 1\n\n    @classmethod\n    def get_n(cls):\n        return cls.n\n\n\nStatic Methods\nStatic methods are methods that are not bound to an instance of a class.\nStatic methods are defined using the @staticmethod decorator. They do NOT take the self parameter and can be called on the class itself.\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    @staticmethod\n    def distance_from_origin(x, y):\n        return ((x ** 2) + (y ** 2)) ** 0.5"
  },
  {
    "objectID": "basics/abstractions/oop1.html#public-protected-and-private-access-levels",
    "href": "basics/abstractions/oop1.html#public-protected-and-private-access-levels",
    "title": "User-defined Types",
    "section": "Public, Protected and Private Access Levels",
    "text": "Public, Protected and Private Access Levels\nIn Python, there are 3 types of access levels:\n\nPublic attributes can be accessed by anyone.\nProtected attributes are those attributes that follow the single underscore _ convention. These attributes should not be accessed directly. However, they can be accessed and modified in a derived class. Accessing protected attributes directly is not considered a good practice.\nPrivate attributes are those attributes that follow the double underscore __ convention. These attributes should not be accessed directly. However, they can be accessed and modified in a derived class. Accessing private attributes directly is not allowed and will result in an AttributeError.\n\n\nclass Car:\n    def __init__(self):\n        self.__maxspeed = 200\n        self._name = \"Supercar\"\n\n    def drive(self):\n        print('driving. maxspeed ' + str(self.__maxspeed))\n\ncar = Car()\ncar.drive()\nprint(car._name)\nprint(car.__maxspeed)\n\ndriving. maxspeed 200\nSupercar\n\n\n\n---------------------------------------------------------------------------\n\nAttributeError                            Traceback (most recent call last)\n\nCell In[2], line 12\n\n     10 car.drive()\n\n     11 print(car._name)\n\n---&gt; 12 print(car.__maxspeed)\n\n\n\nAttributeError: 'Car' object has no attribute '__maxspeed'"
  },
  {
    "objectID": "basics/abstractions/interfaces.html",
    "href": "basics/abstractions/interfaces.html",
    "title": "Interfaces",
    "section": "",
    "text": "Interfaces\n\n\nGenerics",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Interfaces"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures2.html",
    "href": "basics/abstractions/datastructures2.html",
    "title": "Dynamic-Size Reference Data Types",
    "section": "",
    "text": "Collections in Java are dynamic-size data structures that store elements of different types and provide additional functionality for managing and manipulating the data. Java provides a rich set of collection classes in the java.util package that implement various data structures such as lists, sets, maps, queues, and more.\n\n\nThe ArrayList class in Java implements the List interface and provides a dynamic array that can grow or shrink in size. ArrayList allows duplicate elements and maintains the insertion order of elements.\nThe List interface in Java represents an ordered collection of elements that allows duplicate elements. Lists maintain the insertion order of elements and provide methods to add, remove, and access elements by index.\nHere is an example of creating and using an ArrayList:\nimport java.util.ArrayList;\n\n// Create an ArrayList of strings\nArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n\n// Add elements to the ArrayList\nnames.add(\"Alice\");\nnames.add(\"Bob\");\nnames.add(\"Charlie\");\n\n// Access elements by index\nString firstElement = names.get(0); // firstElement = \"Alice\"\n\n// Iterate over the ArrayList\nfor (String name : names) {\n    System.out.println(name); // Output each name\n}\nIn the above example, we created an ArrayList of strings, added elements to the list, accessed elements by index, and iterated over the list using a foreach loop.\n\n\n\nThe HashSet class in Java implements the Set interface and provides a collection of unique elements. HashSet does not allow duplicate elements and does not maintain the insertion order of elements.\nThe Set interface in Java represents a collection of elements that does not allow duplicate elements. Sets do not maintain the insertion order of elements and provide methods to add, remove, and check for the presence of elements.\nHere is an example of creating and using a HashSet:\nimport java.util.HashSet;\n\n// Create a HashSet of integers\nHashSet&lt;Integer&gt; numbers = new HashSet&lt;&gt;();\n\n// Add elements to the HashSet\nnumbers.add(10);\nnumbers.add(20);\nnumbers.add(30);\n\n// Check if an element is present\nboolean containsTwenty = numbers.contains(20); // containsTwenty = true\n\n// Iterate over the HashSet\nfor (int number : numbers) {\n    System.out.println(number); // Output each number\n}\nIn the above example, we created a HashSet of integers, added elements to the set, checked for the presence of an element, and iterated over the set using a foreach loop.\n\n\n\nThe HashMap class in Java implements the Map interface and provides a collection of key-value pairs. HashMap allows null keys and values, and does not maintain the insertion order of elements.\nThe Map interface in Java represents a collection of key-value pairs where each key is unique. Maps provide methods to add, remove, and access elements by key. Java provides several implementations of the Map interface, such as HashMap, TreeMap, and LinkedHashMap.\nHere is an example of creating and using a HashMap:\nimport java.util.HashMap;\n\n// Create a HashMap of student names and IDs\nHashMap&lt;String, Integer&gt; studentIds = new HashMap&lt;&gt;();\n\n// Add key-value pairs to the HashMap\nstudentIds.put(\"Alice\", 101);\nstudentIds.put(\"Bob\", 102);\nstudentIds.put(\"Charlie\", 103);\n\n// Access values by key\nint aliceId = studentIds.get(\"Alice\"); // aliceId = 101\n\n// Iterate over the HashMap\nfor (String name : studentIds.keySet()) {\n    int id = studentIds.get(name);\n    System.out.println(name + \": \" + id); // Output each name and ID\n}\nIn the above example, we created a HashMap of student names and IDs, added key-value pairs to the map, accessed values by key, and iterated over the map to print each name and ID.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Dynamic-Size Reference Data Types"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures2.html#collections",
    "href": "basics/abstractions/datastructures2.html#collections",
    "title": "Dynamic-Size Reference Data Types",
    "section": "",
    "text": "Collections in Java are dynamic-size data structures that store elements of different types and provide additional functionality for managing and manipulating the data. Java provides a rich set of collection classes in the java.util package that implement various data structures such as lists, sets, maps, queues, and more.\n\n\nThe ArrayList class in Java implements the List interface and provides a dynamic array that can grow or shrink in size. ArrayList allows duplicate elements and maintains the insertion order of elements.\nThe List interface in Java represents an ordered collection of elements that allows duplicate elements. Lists maintain the insertion order of elements and provide methods to add, remove, and access elements by index.\nHere is an example of creating and using an ArrayList:\nimport java.util.ArrayList;\n\n// Create an ArrayList of strings\nArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n\n// Add elements to the ArrayList\nnames.add(\"Alice\");\nnames.add(\"Bob\");\nnames.add(\"Charlie\");\n\n// Access elements by index\nString firstElement = names.get(0); // firstElement = \"Alice\"\n\n// Iterate over the ArrayList\nfor (String name : names) {\n    System.out.println(name); // Output each name\n}\nIn the above example, we created an ArrayList of strings, added elements to the list, accessed elements by index, and iterated over the list using a foreach loop.\n\n\n\nThe HashSet class in Java implements the Set interface and provides a collection of unique elements. HashSet does not allow duplicate elements and does not maintain the insertion order of elements.\nThe Set interface in Java represents a collection of elements that does not allow duplicate elements. Sets do not maintain the insertion order of elements and provide methods to add, remove, and check for the presence of elements.\nHere is an example of creating and using a HashSet:\nimport java.util.HashSet;\n\n// Create a HashSet of integers\nHashSet&lt;Integer&gt; numbers = new HashSet&lt;&gt;();\n\n// Add elements to the HashSet\nnumbers.add(10);\nnumbers.add(20);\nnumbers.add(30);\n\n// Check if an element is present\nboolean containsTwenty = numbers.contains(20); // containsTwenty = true\n\n// Iterate over the HashSet\nfor (int number : numbers) {\n    System.out.println(number); // Output each number\n}\nIn the above example, we created a HashSet of integers, added elements to the set, checked for the presence of an element, and iterated over the set using a foreach loop.\n\n\n\nThe HashMap class in Java implements the Map interface and provides a collection of key-value pairs. HashMap allows null keys and values, and does not maintain the insertion order of elements.\nThe Map interface in Java represents a collection of key-value pairs where each key is unique. Maps provide methods to add, remove, and access elements by key. Java provides several implementations of the Map interface, such as HashMap, TreeMap, and LinkedHashMap.\nHere is an example of creating and using a HashMap:\nimport java.util.HashMap;\n\n// Create a HashMap of student names and IDs\nHashMap&lt;String, Integer&gt; studentIds = new HashMap&lt;&gt;();\n\n// Add key-value pairs to the HashMap\nstudentIds.put(\"Alice\", 101);\nstudentIds.put(\"Bob\", 102);\nstudentIds.put(\"Charlie\", 103);\n\n// Access values by key\nint aliceId = studentIds.get(\"Alice\"); // aliceId = 101\n\n// Iterate over the HashMap\nfor (String name : studentIds.keySet()) {\n    int id = studentIds.get(name);\n    System.out.println(name + \": \" + id); // Output each name and ID\n}\nIn the above example, we created a HashMap of student names and IDs, added key-value pairs to the map, accessed values by key, and iterated over the map to print each name and ID.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Dynamic-Size Reference Data Types"
    ]
  },
  {
    "objectID": "basics/controls/controls.html",
    "href": "basics/controls/controls.html",
    "title": "Control Flow",
    "section": "",
    "text": "Programs (multiple lines of code) run each line of code sequentially top to bottom\nStatements (single line of code) run right to left\n\nExpression on right hand side of assignment/boolean operator is executed first\nThen, left hand expression of assignment operator is executed\n\nExpressions ( &lt; 1 line of code) run as per rules of precedence; for operators of equal precedence, expressions run left to right.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow"
    ]
  },
  {
    "objectID": "basics/controls/controls.html#flow-directionality-of-execution",
    "href": "basics/controls/controls.html#flow-directionality-of-execution",
    "title": "Control Flow",
    "section": "",
    "text": "Programs (multiple lines of code) run each line of code sequentially top to bottom\nStatements (single line of code) run right to left\n\nExpression on right hand side of assignment/boolean operator is executed first\nThen, left hand expression of assignment operator is executed\n\nExpressions ( &lt; 1 line of code) run as per rules of precedence; for operators of equal precedence, expressions run left to right.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html",
    "href": "basics/controls/conditionals.html",
    "title": "Conditionals",
    "section": "",
    "text": "Conditionals in Java are used to make decisions based on certain conditions. They allow the program to execute different blocks of code based on whether a condition is true or false. In this tutorial, we will learn about conditionals in Java.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#if-statement",
    "href": "basics/controls/conditionals.html#if-statement",
    "title": "Conditionals",
    "section": "if Statement",
    "text": "if Statement\nThe if statement is used to execute a block of code only if a specified condition is true. If the condition is false, the code block is skipped. The basic syntax of the if statement is as follows:\nif (condition) {\n    // code block to be executed if the condition is true\n}\nHere is an example of using the if statement:\nint x = 10;\n\nif (x &gt; 5) {\n    System.out.println(\"x is greater than 5\");\n}\n\n// Output: x is greater than 5\nIn the above example, the code block inside the if statement is executed because the condition x &gt; 5 is true.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#if-else-statement",
    "href": "basics/controls/conditionals.html#if-else-statement",
    "title": "Conditionals",
    "section": "if-else Statement",
    "text": "if-else Statement\nThe if-else statement is used to execute one block of code if a specified condition is true and another block of code if the condition is false. The basic syntax of the if-else statement is as follows:\nif (condition) {\n    // code block to be executed if the condition is true\n} else {\n    // code block to be executed if the condition is false\n}\nHere is an example of using the if-else statement:\nint x = 3;\n\nif (x &gt; 5) {\n    System.out.println(\"x is greater than 5\");\n} else {\n    System.out.println(\"x is less than or equal to 5\");\n}\n\n// Output: x is less than or equal to 5\nIn the above example, the code block inside the if statement is skipped because the condition x &gt; 5 is false, and the code block inside the else statement is executed.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#if-else-if-else-statement",
    "href": "basics/controls/conditionals.html#if-else-if-else-statement",
    "title": "Conditionals",
    "section": "if-else if-else Statement",
    "text": "if-else if-else Statement\nThe if-else if-else statement is used to execute one block of code if a specified condition is true, another block of code if a different condition is true, and a default block of code if none of the conditions are true. The basic syntax of the if-else if-else statement is as follows:\nif (condition1) {\n    // code block to be executed if condition1 is true\n} else if (condition2) {\n    // code block to be executed if condition2 is true\n} else {\n    // code block to be executed if none of the conditions are true\n}\nHere is an example of using the if-else if-else statement:\nint x = 3;\n\nif (x &gt; 5) {\n    System.out.println(\"x is greater than 5\");\n} else if (x &lt; 5) {\n    System.out.println(\"x is less than 5\");\n} else {\n    System.out.println(\"x is equal to 5\");\n}\nIn the above example, the code block inside the else if statement is executed because the condition x &lt; 5 is true.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#nested-if-statements",
    "href": "basics/controls/conditionals.html#nested-if-statements",
    "title": "Conditionals",
    "section": "Nested if Statements",
    "text": "Nested if Statements\nNested if statements are if statements inside another if statement. They are used to test multiple conditions in sequence. The inner if statement is executed only if the outer if statement’s condition is true. Here is an example of nested if statements:\nint x = 10;\nint y = 20;\n\nif (x == 10) {\n    if (y == 20) {\n        System.out.println(\"x is 10 and y is 20\");\n    }\n}\nIn the above example, the code block inside the inner if statement is executed only if both conditions x == 10 and y == 20 are true.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#ternary-operator",
    "href": "basics/controls/conditionals.html#ternary-operator",
    "title": "Conditionals",
    "section": "Ternary Operator",
    "text": "Ternary Operator\nThe ternary operator ? : is a shorthand way of writing an if-else statement. It is used to assign a value to a variable based on a condition. The basic syntax of the ternary operator is as follows:\nvariable = (condition) ? value1 : value2;\nHere is an example of using the ternary operator:\nint x = 10;\nint result = (x &gt; 5) ? 1 : 0;\n\nSystem.out.println(result);\n\n// Output: 1\nIn the above example, the value of result is assigned 1 if the condition x &gt; 5 is true, and 0 otherwise.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/controls/conditionals.html#switch-statement",
    "href": "basics/controls/conditionals.html#switch-statement",
    "title": "Conditionals",
    "section": "Switch Statement",
    "text": "Switch Statement\nThe switch statement is used to execute different blocks of code based on the value of an expression. It is an alternative to using multiple if-else if-else statements. The basic syntax of the switch statement is as follows:\nswitch (expression) {\n    case value1:\n        // code block to be executed if expression equals value1\n        break;\n    case value2:\n        // code block to be executed if expression equals value2\n        break;\n    ...\n    default:\n        // code block to be executed if none of the values match\n}\nHere is an example of using the switch statement:\nint day = 3;\nString dayName;\n\nswitch (day) {\n    case 1:\n        dayName = \"Monday\";\n        break;\n    case 2:\n        dayName = \"Tuesday\";\n        break;\n    case 3:\n        dayName = \"Wednesday\";\n        break;\n    default:\n        dayName = \"Invalid day\";\n}\n\nSystem.out.println(\"Day: \" + dayName);\n\n// Output: Day: Wednesday\nIn the above example, the value of dayName is assigned based on the value of the day variable using the switch statement.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Conditionals"
    ]
  },
  {
    "objectID": "basics/operations/file_io.html",
    "href": "basics/operations/file_io.html",
    "title": "File I/O",
    "section": "",
    "text": "File Input/Output (I/O) operations are used to read data from files or write data to files. In Java, file I/O operations are performed using classes from the java.io package. In this tutorial, we will learn how to read from and write to files in Java.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "File I/O"
    ]
  },
  {
    "objectID": "basics/operations/file_io.html#reading-from-a-file",
    "href": "basics/operations/file_io.html#reading-from-a-file",
    "title": "File I/O",
    "section": "Reading from a File",
    "text": "Reading from a File\nTo read data from a file in Java, you can use the FileInputStream and BufferedReader classes. The FileInputStream class is used to read bytes from a file, and the BufferedReader class is used to read text from a character-input stream. Here is an example of reading data from a file:\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadFile {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n            String line = reader.readLine();\n            while (line != null) {\n                System.out.println(line);\n                line = reader.readLine();\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\nIn the above example, we use the BufferedReader class to read data from a file named input.txt. We read each line from the file using the readLine() method and print it to the console.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "File I/O"
    ]
  },
  {
    "objectID": "basics/operations/file_io.html#writing-to-a-file",
    "href": "basics/operations/file_io.html#writing-to-a-file",
    "title": "File I/O",
    "section": "Writing to a File",
    "text": "Writing to a File\nTo write data to a file in Java, you can use the FileOutputStream and BufferedWriter classes. The FileOutputStream class is used to write bytes to a file, and the BufferedWriter class is used to write text to a character-output stream. Here is an example of writing data to a file:\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class WriteFile {\n    public static void main(String[] args) {\n        try {\n            BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"));\n            writer.write(\"Hello, World!\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\nIn the above example, we use the BufferedWriter class to write the text “Hello, World!” to a file named output.txt.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "File I/O"
    ]
  },
  {
    "objectID": "basics/operations/operations.html",
    "href": "basics/operations/operations.html",
    "title": "Operations",
    "section": "",
    "text": "An expression is a combination of values, variables, and operators. A value all by itself is considered an expression, and so is a variable, so the following are all legal expressions: 42, x, x+1\n\nWhen you type an expression at the prompt, the interpreter evaluates it, which means that it finds the value of the expression. In this example, x + 1, the interpreter adds one to the current value of x. But it doesn’t display the value unless you tell it to:\n\nx = 42\nx + 1\n\nA statement is a unit of code that has an effect, like creating a variable or displaying a value.\n\nx = 42\nprint(x)\n\nThe first line is an assignment statement that gives a value to x. The second line is a print statement that displays the value of x.\nThe types of statements we have seen so far are assignments and print statements. Other types of statements include:\n\nImport statements: Import a module.\nIf statements: Execute code depending on the value of a condition.\nFor statements: Execute code for each item in a sequence.\nWhile statements: Execute code while a condition is true.\nDef statements: Define a function.\nReturn statements: Exit a function and return a value.\nBreak statements: Exit a loop.\nContinue statements: Skip the rest of the loop body.\n\nWhen you type a statement, the interpreter executes it, which means that it does whatever the statement says. In general, statements don’t have values.\nA program is a sequence of statements. If there is more than one statement, the results appear one at a time as the statements execute.\nFor example, the script below contains three statements:\n\nx = 42\nprint(x)\nx = x + 1\n\nThe output of this program is 42. The second line displays the value of x, which is 42. The third line increases the value of x by one. But it doesn’t display the value.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations"
    ]
  },
  {
    "objectID": "basics/operations/operations.html#expressions-statements-and-programs",
    "href": "basics/operations/operations.html#expressions-statements-and-programs",
    "title": "Operations",
    "section": "",
    "text": "An expression is a combination of values, variables, and operators. A value all by itself is considered an expression, and so is a variable, so the following are all legal expressions: 42, x, x+1\n\nWhen you type an expression at the prompt, the interpreter evaluates it, which means that it finds the value of the expression. In this example, x + 1, the interpreter adds one to the current value of x. But it doesn’t display the value unless you tell it to:\n\nx = 42\nx + 1\n\nA statement is a unit of code that has an effect, like creating a variable or displaying a value.\n\nx = 42\nprint(x)\n\nThe first line is an assignment statement that gives a value to x. The second line is a print statement that displays the value of x.\nThe types of statements we have seen so far are assignments and print statements. Other types of statements include:\n\nImport statements: Import a module.\nIf statements: Execute code depending on the value of a condition.\nFor statements: Execute code for each item in a sequence.\nWhile statements: Execute code while a condition is true.\nDef statements: Define a function.\nReturn statements: Exit a function and return a value.\nBreak statements: Exit a loop.\nContinue statements: Skip the rest of the loop body.\n\nWhen you type a statement, the interpreter executes it, which means that it does whatever the statement says. In general, statements don’t have values.\nA program is a sequence of statements. If there is more than one statement, the results appear one at a time as the statements execute.\nFor example, the script below contains three statements:\n\nx = 42\nprint(x)\nx = x + 1\n\nThe output of this program is 42. The second line displays the value of x, which is 42. The third line increases the value of x by one. But it doesn’t display the value.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations"
    ]
  },
  {
    "objectID": "basics/operations/precedence_associativity.html",
    "href": "basics/operations/precedence_associativity.html",
    "title": "Precedence, Associativity and Type Conversion",
    "section": "",
    "text": "The following table lists the operator precedence in Java. Operators with higher precedence are evaluated before operators with lower precedence. Operators with the same precedence are evaluated from left to right.\nJava operators are listed top to bottom, in descending precedence.\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n()\nParentheses\n\n\n[]\nArray subscript\n\n\n.\nMember access\n\n\n()\nMethod call\n\n\n++, --\nPostfix increment/decrement\n\n\n+, -, ~, !\nUnary plus, Unary minus, Bitwise NOT, Logical NOT\n\n\n*, /, %\nMultiplication, Division, Modulus\n\n\n+, -\nAddition, Subtraction\n\n\n&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;\nBitwise shift left, Bitwise shift right, Bitwise shift right zero fill\n\n\n&lt;, &lt;=, &gt;, &gt;=, instanceof\nRelational less than, Relational less than or equal, Relational greater than, Relational greater than or equal, Type comparison\n\n\n==, !=\nRelational equal, Relational not equal\n\n\n&\nBitwise AND\n\n\n^\nBitwise XOR\n\n\n|\nBitwise OR\n\n\n&&\nLogical AND\n\n\n||\nLogical OR\n\n\n? :\nTernary conditional\n\n\n=, +=, -=, *=, /=, %=, &=, ^=, |=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=\nAssignment, Assignment by sum, Assignment by difference, Assignment by product, Assignment by quotient, Assignment by remainder, Assignment by bitwise AND, Assignment by bitwise XOR, Assignment by bitwise OR, Assignment by bitwise shift left, Assignment by bitwise shift right, Assignment by bitwise shift right zero fill\n\n\n,\nComma"
  },
  {
    "objectID": "basics/operations/precedence_associativity.html#operator-precedence",
    "href": "basics/operations/precedence_associativity.html#operator-precedence",
    "title": "Precedence, Associativity and Type Conversion",
    "section": "",
    "text": "The following table lists the operator precedence in Java. Operators with higher precedence are evaluated before operators with lower precedence. Operators with the same precedence are evaluated from left to right.\nJava operators are listed top to bottom, in descending precedence.\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n()\nParentheses\n\n\n[]\nArray subscript\n\n\n.\nMember access\n\n\n()\nMethod call\n\n\n++, --\nPostfix increment/decrement\n\n\n+, -, ~, !\nUnary plus, Unary minus, Bitwise NOT, Logical NOT\n\n\n*, /, %\nMultiplication, Division, Modulus\n\n\n+, -\nAddition, Subtraction\n\n\n&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;\nBitwise shift left, Bitwise shift right, Bitwise shift right zero fill\n\n\n&lt;, &lt;=, &gt;, &gt;=, instanceof\nRelational less than, Relational less than or equal, Relational greater than, Relational greater than or equal, Type comparison\n\n\n==, !=\nRelational equal, Relational not equal\n\n\n&\nBitwise AND\n\n\n^\nBitwise XOR\n\n\n|\nBitwise OR\n\n\n&&\nLogical AND\n\n\n||\nLogical OR\n\n\n? :\nTernary conditional\n\n\n=, +=, -=, *=, /=, %=, &=, ^=, |=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=\nAssignment, Assignment by sum, Assignment by difference, Assignment by product, Assignment by quotient, Assignment by remainder, Assignment by bitwise AND, Assignment by bitwise XOR, Assignment by bitwise OR, Assignment by bitwise shift left, Assignment by bitwise shift right, Assignment by bitwise shift right zero fill\n\n\n,\nComma"
  },
  {
    "objectID": "basics/operations/precedence_associativity.html#operator-associativity",
    "href": "basics/operations/precedence_associativity.html#operator-associativity",
    "title": "Precedence, Associativity and Type Conversion",
    "section": "Operator Associativity",
    "text": "Operator Associativity\nThe following table lists the operator associativity in Python. Operators with left associativity are evaluated from left to right. Operators with right associativity are evaluated from right to left.\n\n\n\n\n\n\n\nOperator\nAssociativity\n\n\n\n\n**\nRight\n\n\n~\nRight\n\n\n*, /, //, %\nLeft\n\n\n+, -\nLeft\n\n\n&lt;&lt;, &gt;&gt;\nLeft\n\n\n&\nLeft\n\n\n^\nLeft\n\n\n|\nLeft\n\n\n==, !=, &gt;, &gt;=, &lt;, &lt;=, is, is not, in, not in\nLeft\n\n\nnot\nRight\n\n\nand\nLeft\n\n\nor\nLeft\n\n\n=\nRight\n\n\n+=, -=, *=, /=, //=, %=, &=, ^=, |=, &lt;&lt;=, &gt;&gt;=\nRight"
  },
  {
    "objectID": "basics/operations/precedence_associativity.html#implicit-type-conversion",
    "href": "basics/operations/precedence_associativity.html#implicit-type-conversion",
    "title": "Precedence, Associativity and Type Conversion",
    "section": "Implicit Type Conversion",
    "text": "Implicit Type Conversion\n\nAutomatic conversion from one data type to another data type as result of an operation.\n\nPython always converts “smaller” data types to “larger” data types to avoid the loss of information.\n\ninteger_part = 21\nfractional_part = 0.03\n\nprint(\"Datatype of integer_part:\", type(integer_part))\nprint(\"Datatype of fractional_part:\", type(fractional_part))\n\nnew_number = integer_part + fractional_part\n\nprint(\"Value of new_number:\",new_number)\nprint(\"Datatype of new_number:\",type(new_number))\n\nprint(\"Datatype of integer_part:\", type(integer_part))\n\n\ninteger_part = \"21\"\nfractional_part = \"0.03\"\n\nnew_number = integer_part + fractional_part\n\nprint(\"Datatype of integer_part:\", type(integer_part))\nprint(\"Datatype of fractional_part:\", type(fractional_part))\n\nprint(\"Value of new_number:\",new_number)\nprint(\"Datatype of new_number:\",type(new_number))"
  },
  {
    "objectID": "basics/java.html",
    "href": "basics/java.html",
    "title": "PROGRAMMING, IN JAVA",
    "section": "",
    "text": "Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is intended to let application developers Write Once, Run Anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.\nJava is used in a wide variety of computing platforms from embedded devices and mobile phones to enterprise servers and supercomputers. It is also used in developing games, mobile applications, and enterprise software. Some popular software written in Java includes Workday, Minecraft and essentially all Android applications.\nJava up until very recently was the most popular programming language in the world. In recent years, it has been overtaken by Python (came out in 1991) and JavaScript (came out in 1995) in terms of popularity, but it still remains one of the most widely used programming languages in the world. In fact, Java is still the most popular programming language in the world for developing enterprise applications (applications used by businesses and organizations).\nRanking of Java as measured by different indexes:\nIn recent years, JVM languages like Kotlin and Scala have also gained popularity. Kotlin is a modern programming language that is fully interoperable with Java and is used to develop Android applications. Scala is a functional programming language that is also interoperable with Java and is used to develop big data applications.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#java-architecture",
    "href": "basics/java.html#java-architecture",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Java Architecture",
    "text": "Java Architecture\nJava was developed by Sun Microsystems (which has since been acquired by Oracle) and released in 1995. For the time, it was a revolutionary language that was designed to be platform-independent, meaning that it could run on any device hardware that had a Java Virtual Machine (JVM).\n\nThe Java platform consists of three main components:\n\nJava Development Kit (JDK): JDK is a software development kit used to develop Java applications and applets. It includes the JRE, an interpreter/loader (Java), a compiler (javac), an archiver (jar), a documentation generator (Javadoc), and other tools needed in Java development.\nJava Runtime Environment (JRE): JRE is a software package that provides Java class libraries, along with Java Virtual Machine (JVM), and other components to run applications written in Java programming.\nJava Virtual Machine (JVM): JVM is a software that can be ported to different hardware platforms and execute Java bytecode.\n\nBefore Java, most programming languages were compiled to platform-specific machine code as an executable file or binary e.g. .exe in Windows or .app in macOS. This meant that the same executable (application file or binary) could not run on different platforms, since the machine code was different. Java solved this problem by compiling to an intermediate bytecode that could be run on any platform that had a JVM.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#setting-up-vs-code-for-java-development",
    "href": "basics/java.html#setting-up-vs-code-for-java-development",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Setting up VS Code for Java development",
    "text": "Setting up VS Code for Java development\nTo help you set up quickly, you can install the [Coding Pack for Java], which includes VS Code, the Java Development Kit (JDK), and essential Java extensions. The Coding Pack can be used as a clean installation, or to update or repair an existing development environment.\n\nInstall the Coding Pack for Java - Windows\nInstall the Coding Pack for Java - macOS\n\nNote: The Coding Pack for Java is only available for Windows and macOS. For other operating systems, you will need to manually install a JDK, VS Code, and Java extensions.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#creating-a-source-code-file",
    "href": "basics/java.html#creating-a-source-code-file",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Creating a source code file",
    "text": "Creating a source code file\nCreate a folder for your Java program and open the folder with VS Code. Then in VS Code, create a new file and save it with the name Hello.java. When you open that file, the Java Language Server automatically starts loading, and you should see a language status item with a loading icon on the right side of the Status Bar showing the language status is busy. After it finishes loading, you can hover on the language status item and find the loading process has been finished successfully. You can also choose to pin the status item in the status bar.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you open a Java file in VS Code without opening its folder, the Java Language Server might not work properly.\n\n\nVS Code will also try to figure out the correct package for the new type and fill the new file from a template. See Create new file.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#creating-a-java-project",
    "href": "basics/java.html#creating-a-java-project",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Creating a Java project",
    "text": "Creating a Java project\nYou can also create a Java project using the Java: Create Java Project command. Bring up the Command Palette (⇧⌘P) and then type java to search for this command. After selecting the command, you will be prompted for the location and name of the project. You can also choose your build tool from this command.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#running-and-debugging-your-program",
    "href": "basics/java.html#running-and-debugging-your-program",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Running and debugging your program",
    "text": "Running and debugging your program\nTo run and debug Java code, set a breakpoint, then either press F5 on your keyboard or use the “Run &gt; Start Debugging” menu item. You can also use the “Run|Debug” CodeLens option in the editor. After the code compiles, you can see all your variables and threads in the “Run and Debug” view.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#java-vs.-python",
    "href": "basics/java.html#java-vs.-python",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Java vs. Python",
    "text": "Java vs. Python\nBefore we dive into “Hello World” in Java, let’s first understand the differences between programming in Java and programming in Python.\nProgramming in Java is different from programming in Python primarily because:\n\nJava is very strictly an object-oriented language, whereas Python is a multi-paradigm language. This means that Java is designed around the concept of objects and classes, whereas Python can be used in an object-oriented, procedural, or functional style. Every Java program must be inside a class, and every program must have a main method. In Python, you can write code outside of a class or function.\nJava is a statically typed language. This means that you have to declare the type of a variable when you declare it. For example, in Java, you would declare a variable as int x = 5;, whereas in Python, you would declare a variable as x = 5.\nJava is a compiled language, where Python is an interpreted language. This means that running a Java program is a two-step process:\n\nfirst you compile the Java code into bytecode, and then\nyou run the bytecode on the Java Virtual Machine (JVM). In Python, you run the Python code in one-step that is directly on the Python interpreter.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "basics/java.html#hello-world",
    "href": "basics/java.html#hello-world",
    "title": "PROGRAMMING, IN JAVA",
    "section": "Hello World",
    "text": "Hello World\nThe following is a simple Java program that prints “Hello, World!” to the console:\n\nJavaPythonPython (OOP)\n\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n\nprint(\"Hello, World!\")\n\n\nclass HelloWorld:\n    def __init__(self):\n        print(\"Hello, World!\")\n\n\n\nLet’s break down the Java program line by line:\n\npublic class HelloWorld {\nThis line declares a class named HelloWorld.\n\nIn Java, every program must be inside a class.\nThe class name must match the name of the file. In this case, the file is named HelloWorld.java, so the class name must be HelloWorld.\nThe public keyword is an access modifier that specifies that the class is accessible from other classes. Every class in Java must have an access modifier: public, private, protected, or package-private.\nThe {} delimits the body of the class. In Java, {} is used to delimit blocks of code. Python uses indentation to delimit blocks of code.\n\n\n\n\n  public static void main(String[] args) {\nThis line declares a method named main.\n\nIn Java, the main method is the entry point of the program.\nThe public keyword is an access modifier that specifies that the method is accessible from other classes. Similar to the class, every method in Java must have an access modifier.\nThe static keyword means that the method belongs to the class, not an instance of the class.\nThe void keyword means that the method does not return a value.\nThe String[] args parameter is an array of strings that are passed to the main method.\n\n\n\n\n    System.out.println(\"Hello, World!\");\nThis line prints “Hello, World!” to the console.\n\nThe System.out.println method is used to print a string to the console. This is a method of the System.out object, which is a static member of the System class that represents the standard output stream. This is imported by default in every Java program.\nNote that the println is equivalent to the built-in print() function in Python.\nNote that semi-colon ; is used to end the statement. This is mandatory in Java. Every statement in Java must end with a semi-colon. In contrast, Python uses whitespace to delimit statements.\n\n\n\n\n  }\nThis line marks the end of the main method.\n\n\n\n}\nThis line marks the end of the HelloWorld class.\n\n\nData (values and variables) are to code what nouns are to prose.\nOperations (arithmetic, logical, relational) are the verbs.\nControl flow (if-else, loops) are the plot.\nAbstractions (functions, classes) are metaphors.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA"
    ]
  },
  {
    "objectID": "se/interview.html",
    "href": "se/interview.html",
    "title": "Technical Interviews",
    "section": "",
    "text": "Technical Interviews are a common part of the hiring process for software engineers. They are used to assess a candidate’s technical knowledge, problem-solving skills, and ability to work under pressure. Many companies use multiple rounds of technical interviews to evaluate candidates, and the questions asked can cover a wide range of topics, including data structures, algorithms, and system design.\nThe hiring process at a typical tech company might include a phone screen, a coding challenge, and multiple rounds of technical interviews. The technical interviews are usually conducted by engineers at the company, and they can be conducted in person or remotely. During the interview, the candidate is asked to solve coding problems on a whiteboard or a computer, and they are expected to explain their thought process as they work through the problem.\nTechnical interviews are generally about an hour long and involve solving one or two coding problems. At the end of the interview, the candidate is usually given the opportunity to ask questions about the company or the role.\nMost technical interviews focus on problem-solving skills and algorithmic thinking. Candidates are expected to be able to write clean, efficient code and to explain their solutions clearly. In addition to coding problems, technical interviews may also include questions about system design, object-oriented design, and other technical topics.\nThe following video shows a mock technical interview that you can watch to get a sense of what to expect in a technical interview:",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Technical Interviews"
    ]
  },
  {
    "objectID": "se/interview.html#leetcode",
    "href": "se/interview.html#leetcode",
    "title": "Technical Interviews",
    "section": "LeetCode",
    "text": "LeetCode\nLeetCode is a popular platform for practicing coding interview questions, and many candidates use it to prepare for technical interviews. The problems on LeetCode cover a wide range of topics and difficulty levels, making it a valuable resource for interview preparation.\nLeetCode premium allows simulating interviews with questions from specific companies like Google, Facebook, Amazon, and Microsoft. It also provides video solutions and additional features to help you prepare for technical interviews.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Technical Interviews"
    ]
  },
  {
    "objectID": "se/interview.html#neetcode",
    "href": "se/interview.html#neetcode",
    "title": "Technical Interviews",
    "section": "Neetcode",
    "text": "Neetcode\nThe incredible breadth of problems on LeetCode can be overwhelming for beginners. You might want to consider starting with a smaller curated list of 75 problems called the “Blind 75”. This is a very popular tech insider shortlist of commonly asked interview questions. The best place to start with Blind 75, in my opinion, is NeetCode. The roadmap on the website is a great way to sequentially work through categories of problems. Moreover, each problem has an accompanying youtube video that does a great job at explaining the problem and the solution.\nCompetitive Programming: If you enjoyed the competitive programming aspect of the course, I would first recommend marking your calendar with The Thirty-First Annual CCSE: Southeastern Programming Contest is scheduled for 10 a.m.-1 p.m. on Saturday, November 2, 2024 in Riley Hall at Furman University. I honestly believe that we can beat Bob Jones and win the competition this year! The problems from past years are here. You should continue practicing these on your own with a stopwatch running (optionally with the Eye of the Tiger playing in the background).",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Technical Interviews"
    ]
  },
  {
    "objectID": "se/interview.html#hiring-process",
    "href": "se/interview.html#hiring-process",
    "title": "Technical Interviews",
    "section": "Hiring Process",
    "text": "Hiring Process\nHiring process at FAANG (Facebook, Amazon, Apple, Netflix, Google) companies is explained here and Interviewing.io has a blog that provides insights into the technical interview process. For instance, this link gives a pretty good overview of the hiring process at big tech companies. The processes are also broken down by company, for example, Google.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Technical Interviews"
    ]
  },
  {
    "objectID": "se/shell.html",
    "href": "se/shell.html",
    "title": "Shell (sh)",
    "section": "",
    "text": "Note\n\n\n\nDemonstrating deployment using git\nShell is a program that takes commands from the keyboard and gives them to the operating system to perform.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#preliminaries",
    "href": "se/shell.html#preliminaries",
    "title": "Shell (sh)",
    "section": "0. Preliminaries",
    "text": "0. Preliminaries\n\n0.1. File Structure\nFile structure is a way of organizing files and directories in a computer. Most operating systems use a hierarchical file system.\n\n\n\n\n\n0.2. File Path\nFile path is the location of a file or folder in a directory structure. An example of a file is C:\\Users\\Documents\\file.txt.\n\n\n\n\n\n\nTip\n\n\n\nNote that Unix based systems (e.g. MacOS, Linux etc.) use / whereas Windows uses \\ as the path separator.\n\n\nThe file path is made up of the drive name (e.g. C:\\), the folders (e.g. Users\\), and the file name (e.g. Documents\\file.txt).",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#launch-command-line-interface",
    "href": "se/shell.html#launch-command-line-interface",
    "title": "Shell (sh)",
    "section": "1. Launch Command Line Interface",
    "text": "1. Launch Command Line Interface\n\nMacOSWindows\n\n\n\nPress Command + Space to open Spotlight Search.\nType terminal and press Enter.\n\n\n\n\n\nPress Win + R to open the Run dialog box.\nType cmd and press Enter.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#where-am-i",
    "href": "se/shell.html#where-am-i",
    "title": "Shell (sh)",
    "section": "2. Where Am I?",
    "text": "2. Where Am I?\n\nMacWindows\n\n\npwd command is used to print the current working directory.\n\n\ncd command, without any parameters, is used to print the current working directory.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#whats-in-here",
    "href": "se/shell.html#whats-in-here",
    "title": "Shell (sh)",
    "section": "3. What’s in Here?",
    "text": "3. What’s in Here?\n\nMacWindows\n\n\nls [OPTION]... [FILE]...\nls command is used to list the files and directories in the current working directory.\nls -lt command is used to list the files and directories in the current working directory in long listing format and sorted by time modified.\n\n\ndir command is used to list the files and directories in the current working directory.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#lets-go",
    "href": "se/shell.html#lets-go",
    "title": "Shell (sh)",
    "section": "4. Let’s Go!",
    "text": "4. Let’s Go!\nThe following can be used to jump to locations: cd &lt;location you want to move to&gt; (Change Directory)\nSome common shortcuts:\n\n~: Home Directory\n.: Current Directory\n..: Parent Directory\n/: Root Directory",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/shell.html#lets-create-a-folder",
    "href": "se/shell.html#lets-create-a-folder",
    "title": "Shell (sh)",
    "section": "5. Let’s create a folder",
    "text": "5. Let’s create a folder\nA folder can be created using mkdir &lt;folder name&gt;",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Shell (sh)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html",
    "href": "se/version_control/git_colab.html",
    "title": "Git (Team)",
    "section": "",
    "text": "When working in a team, it is important to have a good version control system. Git is a popular version control system that allows you to keep track of changes to your code and collaborate with others. In this guide, we will cover some of the basics of using Git in a team setting.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#git-fetch",
    "href": "se/version_control/git_colab.html#git-fetch",
    "title": "Git (Team)",
    "section": "git fetch",
    "text": "git fetch\nThe git fetch command is used to download changes from a remote repository. It will download any new branches or changes that have been made since the last time you fetched.\n$ git fetch\nThese changes will be downloaded to your local repository, but they will not be merged into your working directory. To merge the changes into your working directory, you can use the git merge command.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#git-merge",
    "href": "se/version_control/git_colab.html#git-merge",
    "title": "Git (Team)",
    "section": "git merge",
    "text": "git merge\nThe git merge command is used to merge changes from one branch into another. It will take the changes from the specified branch and apply them to the current branch.\n$ git merge &lt;branch name&gt;\nIf there are any conflicts between the two branches, Git will prompt you to resolve them before completing the merge.\nThere are two ways to resolve conflicts: manually editing the conflicted files or using a merge tool. Some popular merge tools include vimdiff, kdiff3, and meld.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#git-pull",
    "href": "se/version_control/git_colab.html#git-pull",
    "title": "Git (Team)",
    "section": "git pull",
    "text": "git pull\nThe git pull command is a combination of git fetch and git merge. It will download changes from a remote repository and merge them into your working directory in one step.\n$ git pull",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#resolving-conflicts",
    "href": "se/version_control/git_colab.html#resolving-conflicts",
    "title": "Git (Team)",
    "section": "Resolving Conflicts",
    "text": "Resolving Conflicts\nConflicts can occur when the same lines of code have been changed in both branches. You will need to manually resolve these conflicts before the merge can be completed.\nThe way to resolve conflicts is to open the conflicted file in your text editor and manually edit the file to resolve the conflicts. Once you have resolved all the conflicts, you can save the file and commit the changes. This manual edit process takes place in the working directory after a merge has been attempted and failed due to conflicts.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#pull-requests",
    "href": "se/version_control/git_colab.html#pull-requests",
    "title": "Git (Team)",
    "section": "Pull Requests",
    "text": "Pull Requests\nPull requests are a way to propose changes to a repository and collaborate with others. When you create a pull request, you are asking the repository owner to review and merge your changes into the main branch.\nTo create a pull request, you will need to push your changes to a remote branch and then create the pull request on the Git hosting service.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_colab.html#working-with-branches",
    "href": "se/version_control/git_colab.html#working-with-branches",
    "title": "Git (Team)",
    "section": "Working with Branches",
    "text": "Working with Branches\nBranches are an important concept in Git that allow you to work on different features or fixes in isolation. When you create a new branch, you are creating a new line of development that is independent of the main branch (usually called master or main).\nTo create a new branch, you can use the git checkout -b command. This will create a new branch and switch to it in one step.\n$ git checkout -b &lt;branch name&gt;\nOnce you have made changes on a branch, you can merge those changes back into the main branch using the git merge command.\n$ git checkout main\n$ git merge &lt;branch name&gt;\n\n\n\nAt any point, you can check which branch you are on using the git branch command.\n$ git branch",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Team)"
    ]
  },
  {
    "objectID": "se/version_control/git_solo.html#initial-setup",
    "href": "se/version_control/git_solo.html#initial-setup",
    "title": "Git (Individual)",
    "section": "Initial Setup",
    "text": "Initial Setup\n\nIf this is the first time you’ve installed Git, you may need to configure it. You only need to do this once per machine.\nYou can configure your Git username and email using the following commands, replacing John Doe’s info with your own.\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\nThese details will be associated with any commits that you make and blame will be correctly assigned.\n\n\nStarting from scratch\n\nFire it up: git init\nGit init is a one-time command you use during the initial setup of a new repo. Executing this command will create a new Git repository in the current directory. This will create a new subdirectory named .git that contains all of your necessary repository files — a Git repository skeleton. At this point, nothing in your project is tracked yet. (See the next section to learn how to start tracking files.)\n\n\n\n\n\n\nLink it to your Github repository: git remote add origin\nGit remote is a command to manage the set of remotes associated with a repository. A remote in Git is a common repository that all team members use to exchange their changes. In most cases, such a remote repository is stored on a code hosting service like GitHub or on an internal server. In contrast to a local repository, a remote typically does not provide a file tree of the project’s current state. Instead, it only consists of the .git versioning data.\n$ git remote add origin &lt;remote repository URL&gt;\n$ git remote -v\n\n\n\n\nThe remote repository URL is the URL of the repository on GitHub. The git remote -v command lists the URLs that Git has stored for the shortname to be used when reading and writing to that remote.\nOn Github, you can find the URL of your repository by clicking on the green button that says “Code” and copying the URL that appears under SSH tab.\n\n\n\nStarting from an existing repo on Github\nGit clone is a command for downloading existing source code from a remote repository (like Github, for example). Cloning a repository downloads an exact copy of all the repository data that GitHub has at that point in time, including all versions of every file and folder for the project. You can push your changes to the remote repository on GitHub, or pull other people’s changes from GitHub.\nThe syntax for git clone is as follows:\n$ git clone &lt;repo URL&gt;\nYou can find the URL of your repository by clicking on the green button that says “Code” and copying the URL that appears under SSH tab.\nYou don’t need to run git init or git remote add origin if you are cloning an existing repository.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Individual)"
    ]
  },
  {
    "objectID": "se/version_control/git_solo.html#workflow-individual",
    "href": "se/version_control/git_solo.html#workflow-individual",
    "title": "Git (Individual)",
    "section": "Workflow (individual)",
    "text": "Workflow (individual)\nWhen you are not collaborating with others, using git is pretty straightforward.\nIn git, there are four main states that your files can reside in. They are:\n\nuntracked: means that Git sees the file as a new file that has not been committed to the database yet.\nstaged: means that you have marked a modified file in its current version to go into your next commit snapshot.\ncommitted: means that the data is safely stored in your local database.\npushed: means that your data has been transferred to a remote repository.\n\n\n\n\n\n1. git status\nGit status is a command that displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.\n\n\n\n\n\n\n\n* git diff (optional)\nGit diff is a multi-use Git command that when executed runs a diff function on Git data sources. These data sources can be commits, branches, files and more. The git diff command is often used along with git status and git log to analyze the current state of a Git repo.\n\n\n\n\n\n2. git add\nGit add is a command used to add files to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, git add doesn’t really affect the repository in any significant way—changes are not actually recorded until you run git commit.\n\ngit add &lt;file-name-1&gt;\ngit add &lt;file-name-2&gt;\ngit add &lt;file-name-3&gt;\n:\ngit add &lt;file-name-n&gt;\n\n\n\n3. git commit\nGit commit is a command used to save the changes to the local repository. Note that git commit alone doesn’t send changes to the remote repository. It only records changes to the local repository. To send those changes to the remote repository, you need to execute git push.\n\ngit commit -m &lt;Short text msg to communicate what are the changes made in the snapshot being committed&gt;\n\n\n\n5. git push\nGit push is a command used to upload local repository content (stuff that has been commit-ted) to a remote repository. The syntax for git push is as follows: git push -u  &lt;name of remote branch&gt; &lt;name of local branch&gt;. In most situtations, you will be pushing to the main branch of the origin remote repository. In that case, the command will be\ngit push -u origin main",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Individual)"
    ]
  },
  {
    "objectID": "se/version_control/git_solo.html#umm..-idk-what-happened",
    "href": "se/version_control/git_solo.html#umm..-idk-what-happened",
    "title": "Git (Individual)",
    "section": "Umm.. IDK what happened…",
    "text": "Umm.. IDK what happened…\n\n\n\n\n\n\nTip\n\n\n\nThis webpage, with an easy to remember name, is a great resource for such situations!\n\n\nWhile working on a project, you may find yourself in a situation where you need to undo a commit. Git offers two main ways to undo changes to commits: git revert and git reset.\n\ngit log\nThe first thing you should do is when you inevitably mess up is to assess the situation and identify the most recent commit up to which everything was working fine.\nGit log is a command used to display the commit history of a repository. By default, git log displays the commit hash, the author and the commit message. The git log command allows you to customize the output using a large number of flags and options.\nIt is often a good idea to use git log --oneline to get a more concise view of the commit history.\n\n\n\n\n\n\nGit reset is a powerful command that is used to undo local changes to the state of a Git repo. Git reset operates on “The Three Trees of Git”. These trees are the Commit History ( HEAD ), the Staging Index, and the Working Directory.\n\n\ngit revert\nrevert is the command we use when we want to take a previous commit and add it as a new commit, keeping the log intact.\nStep 1: Find the previous commit:\n\n\n1.1. First thing, we need to find the point we want to return to. To do that, we need to go through the log.\nTo avoid the very long log list, we are going to use the --oneline option, which gives just one line per commit showing i) the first seven characters of the commit hash and ii) the commit message\nStep 2: Use it to make a new commit:\n\n\ngit revert HEAD --no-edit\nTo revert to earlier commits, use git revert HEAD~x (x being a number. 1 going back one more, 2 going back two more, etc.)\n\n\ngit reset\nreset is the command we use when we want to go back to a previous commit and erase everything that happened after it.\n\n\n\nSimilar to revert, we first need to find the commit we want to go back to using git log.\nNext, we need to use the reset command.\nTo reset to earlier commits, use git reset followed by the first seven characters of the commit hash of the commit you want to go back to.\ngit reset 1a2b3c4d",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Git (Individual)"
    ]
  },
  {
    "objectID": "se/se.html",
    "href": "se/se.html",
    "title": "SOFTWARE ENGINEERING",
    "section": "",
    "text": "Software engineering is the application of engineering to the design, development, implementation, testing, and maintenance of software in a systematic method.\nIt is a very broad field that includes a wide range of subfields. In this course, we will primarily focus on version control and a popular software development methodology called Test-Driven Development (TDD).",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING"
    ]
  },
  {
    "objectID": "se/version_control/github.html",
    "href": "se/version_control/github.html",
    "title": "Github (Community)",
    "section": "",
    "text": "GitHub is a code hosting platform for version control and and social network for collaboration. It lets you and others work together on projects from anywhere.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#sign-up-for-github",
    "href": "se/version_control/github.html#sign-up-for-github",
    "title": "Github (Community)",
    "section": "Sign up for GitHub",
    "text": "Sign up for GitHub\nIf you don’t already have an account, you can sign up for a free account at github.com\n\nThis process is like signing up for any other web service. You’ll need to: pick a username, provide an email address and choose a password. Fairly standard stuff.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#github-profile",
    "href": "se/version_control/github.html#github-profile",
    "title": "Github (Community)",
    "section": "Github Profile",
    "text": "Github Profile\nYour GitHub profile is the place where you can share information about yourself, your projects, and your interests. You can also use it to follow other developers, discover new code, and contribute to projects.\nIt is a good idea to add a profile picture and a bio to your profile. This will help others to know who you are and what you are interested in.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#repositories-and-projects",
    "href": "se/version_control/github.html#repositories-and-projects",
    "title": "Github (Community)",
    "section": "Repositories and Projects",
    "text": "Repositories and Projects\nA repository is the most basic element of GitHub. They’re easiest to imagine as a project’s folder. A repository contains all of the project files (including documentation), and stores each file’s revision history. Repositories can have multiple collaborators and can be either public or private.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#creating-a-repository",
    "href": "se/version_control/github.html#creating-a-repository",
    "title": "Github (Community)",
    "section": "Creating a Repository",
    "text": "Creating a Repository\nA repository is usually used to organize a single project. Repositories can contain folders and files, images, videos, spreadsheets, and data sets – anything your project needs. Often, repositories include a README file, a file with information about your project. README files are written in the plain text Markdown language. You can use this cheat sheet to get started with Markdown syntax. GitHub lets you add a README file at the same time you create your new repository. GitHub also offers other common options such as a license file, but you do not have to select any of them now.\nYour hello-world repository can be a place where you store ideas, resources, or even share and discuss things with others.\n\nIn the upper-right corner of any page, use the drop-down menu, and select New repository.\n\n\n\n\n\n\nType a name for your repository, and an optional description.\n\n\n\n\n\n\nChoose Public for repository visibility.\n\n\n\nClick Create repository.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#add-ssh-key-to-github",
    "href": "se/version_control/github.html#add-ssh-key-to-github",
    "title": "Github (Community)",
    "section": "Add SSH key to GitHub",
    "text": "Add SSH key to GitHub\n\nGo to your GitHub account settings and click on SSH and GPG keys. Then click on New SSH key. Give a title to your key (ideally this should be something like Macbook 2023) and paste the key in the box below. Click on Add SSH key.\n\nCopy the SSH public key to your clipboard. If your SSH public key file has a different name than the example code, modify the filename to match your current setup. When copying your key, don’t add any newlines or whitespace.  \nIn the upper-right corner of any page, click your profile photo, then click Settings.  \nIn the “Access” section of the sidebar, click SSH and GPG keys.  \nClick New SSH key or Add SSH key.  \nIn the “Title” field, add a descriptive label for the new key. For example, if you’re using a personal laptop, you might call this key “Personal laptop”.  \nIn the “Key” field, paste your public key.  \nClick Add SSH key.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#fork-a-repository",
    "href": "se/version_control/github.html#fork-a-repository",
    "title": "Github (Community)",
    "section": "Fork a Repository",
    "text": "Fork a Repository\nA fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.\nMost commonly, forks are used to either propose changes to someone else’s project or to use someone else’s project as a starting point for your own idea.\nTo fork a repository, click the Fork button in the header of the repository.\n\n\n\n\nAfter forking the repository, you can clone it to your local machine and make changes. Once you are done, you can create a pull request to propose your changes to the original repository.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/github.html#pull-requests",
    "href": "se/version_control/github.html#pull-requests",
    "title": "Github (Community)",
    "section": "Pull Requests",
    "text": "Pull Requests\nWhen you are ready to share your work, submit a pull request. Pull requests show differences between the content from both branches. The changes, additions, and subtractions are shown in green and red.\nAs soon as you make a commit, you can open a pull request and start a discussion, even before the code is finished.\nBy using GitHub’s @mention system in your pull request message, you can ask for feedback from specific people or teams, whether they’re down the hall or 10 time zones away.\nYou can even open pull requests in your own repository and merge them yourself. It’s a great way to learn the GitHub flow before working on larger projects.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Github (Community)"
    ]
  },
  {
    "objectID": "se/version_control/version_control.html",
    "href": "se/version_control/version_control.html",
    "title": "Version Control",
    "section": "",
    "text": "Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later.\nIt allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more.\nVersion control systems (VCS) are tools used to track changes to source code (or other collections of files and folders). As the name implies, these tools help maintain a history of changes; furthermore, they facilitate collaboration.\nVCSs track changes to a folder and its contents in a series of snapshots, where each snapshot encapsulates the entire state of files/folders within a top-level directory. VCSs also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.\nIndividual snapshots can be compared to each other, and differences can be extracted. For example, you can ask questions like what changed between this snapshot and the previous snapshot? Who made those changes? etc.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control"
    ]
  },
  {
    "objectID": "se/version_control/version_control.html#git",
    "href": "se/version_control/version_control.html#git",
    "title": "Version Control",
    "section": "Git",
    "text": "Git\n\nWhile other VCSs exist, Git is the de facto standard for version control. This XKCD comic captures Git’s reputation:\nBecause Git’s interface is a leaky abstraction, learning Git top-down (starting with its interface / command-line interface) can lead to a lot of confusion. It’s possible to memorize a handful of commands and think of them as magic incantations, and follow the approach in the comic above whenever anything goes wrong.\n\n\n\n\n\n\nNote\n\n\n\n\n“I’m not a nice person and I don’t care about you”\nGit was developed by Linus Torvalds, who also created the open source operating system Linux (portmanteau of Linus and Unix).\nTorvalds is known for his technical brilliance but also his very abrasive personality. This interview on TED and New Yorker profile of Torvalds is a good introduction to him.”",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control"
    ]
  },
  {
    "objectID": "se/ssh.html",
    "href": "se/ssh.html",
    "title": "Secure Shell (ssh)",
    "section": "",
    "text": "Just as HTTP is a protocol for unencrypted web traffic and HTTPS is a protocol for encrypted web traffic, SSH is a protocol for encrypted remote login and other secure network services.\nUsing the SSH protocol, you can connect and authenticate to remote servers and services.\nIn simple words, you can use SSH to access another computer over a network and execute commands on the other computer. All of this takes place in the command line, without needing a graphical interface. This is how most servers are administered.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Secure Shell (ssh)"
    ]
  },
  {
    "objectID": "se/ssh.html#ssh-keys",
    "href": "se/ssh.html#ssh-keys",
    "title": "Secure Shell (ssh)",
    "section": "SSH Keys",
    "text": "SSH Keys\nSSH keys are a way to identify trusted computers and communicate with them without involving passwords.\nSSH keys are two files that are generated together: a public key and a private key. The private key is kept on the computer you log in from, while the public key is shared with all the computers you want to log communicate with.\n\n\n\n\n\n\nCaution\n\n\n\nNever share or upload your private SSH key!\n\n\n\n\n\n\nCheck if you already have an SSH key\nIf you want to check if you already have an SSH key, you can use the following command:\nls -al ~/.ssh\n\n\n\n\n\n\nNote\n\n\n\nFor Windows Users If you are using Windows and the above command does not work, you can use the following commands: dir ~/.ssh or notepad ~/.ssh/id_rsa.pub\nAlternatively, check [your home directory]/.ssh/id_rsa where [your home directory] is the directory where your home directory (C:) is located.\nWorst case, just download and install Git Bash or PuTTY.\n\n\nls: prints the contents of a directory -a: list all files in long format -l: use a long listing format ~/.ssh: path to the ssh folder ~: home directory .ssh: hidden ssh folder in your home directory\nIf you see a file named id_rsa.pub, you already have an SSH key pair and you can skip the next step.\nThe filename ending with .pub is your public key. The other file is the corresponding private key. If you don’t have these files (or you don’t even have a .ssh directory), you need to create them.\n\n\nGenerate a new SSH key, if needed\nSSH keys are generated using a command line tool called ssh-keygen. This tool is installed by default on most systems.\n\nssh-keygen -t ed25519 -C \"your_email@example.com\"\n    \n-t: the type of encryption to use\ned25519: the encryption type\n-C: comment to help you identify the key\nTry the ls -al ~/.ssh command again to see your new SSH key.\n\n\nCopy the SSH key to your clipboard\n\nMacWindows\n\n\npbcopy &lt; ~/.ssh/id_rsa.pub\n\n\nclip &lt; ~/.ssh/id_rsa.pub\n\n\n\nNow you can paste your public ssh key on the website you want to use it on.",
    "crumbs": [
      "Home",
      "SOFTWARE ENGINEERING",
      "Version Control",
      "Secure Shell (ssh)"
    ]
  },
  {
    "objectID": "basics/operations/tmp.html",
    "href": "basics/operations/tmp.html",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "",
    "text": "Which of the following is True about the Java architecture?\n\n\nJava code is compiled into bytecode by the Java Development Kit (JDK)\nBytecode is an intermediate representation of the Java code that is executed by the Java Virtual Machine (JVM).\nBytecode is executed by the Java Virtual Machine (JVM) to produce machine code that runs on the underlying hardware.\nJRE is the Java Runtime Environment that includes the JVM and other libraries.\nAll of the above\n\nAnswer: D) All of the above\n\nJava is a:\n\n\nCompiled language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nInterpreted language: Java code is interpreted by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nBoth compiled and interpreted language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\nNone of the above\n\nAnswer: A) Compiled language: Java code is compiled into bytecode by the Java Development Kit (JDK) and executed by the Java Virtual Machine (JVM).\n\nJava programming can only be done in Visual Studio Code.\n\n\nTrue\nFalse\n\nAnswer: B) False\n\nJava is a statically typed language, which means:\n\n\nThe data type of a variable is determined at runtime and can change during execution.\nThe data type of a variable is determined at compile time and cannot change.\nThe data type of a variable is determined by the Java Virtual Machine (JVM) at runtime.\nThe data type of a variable is determined by the Java Development Kit (JDK) at runtime.\n\nAnswer: B) The data type of a variable is determined at compile time.\n\nWhich of the following is True about Object-Oriented Programming (OOP) in Java and Python?\n\n\nObject Oriented Programming (OOP) is supported in both Java and Python.\nPython supports Object-Oriented Programming (OOP) but is a multi-paradigm language that also supports procedural and functional programming paradigms on the same level as OOP.\nJava is said to be a pure Object-Oriented Programming (OOP) language because OOP is the primary programming paradigm in Java.\nAll of the above\n\nAnswer: D) All of the above\n\nWhich of the following is True?\n\n\nJava is a statically typed language and Python is a dynamically typed language.\nJava is a dynamically typed language and Python is a statically typed language.\nBoth Java and Python are statically typed languages.\nBoth Java and Python are dynamically typed languages.\n\nAnswer: A) Java is a statically typed language and Python is a dynamically typed language.\n\nWhich of the following best describes the difference between Java and Python? Select all that apply.\n\n\nJava is a scripting language and Python is a compiled language.\nJava is a compiled language and Python is an interpreted language.\nJava is a dynamically typed language and Python is a statically typed language.\nJava is a statically typed language and Python is a dynamically typed language.\n\nAnswer: B) Java is a compiled language and Python is an interpreted language. D) Java is a statically typed language and Python is a dynamically typed language.\n\nIn Java, every line of code must be inside a:\n\n\nMethod\nClass\nInterface\nPackage\n\nAnswer: B) Class\n\nClass name in Java must:\n\n\nStart with a lowercase letter.\nStart with an uppercase letter.\nStart with a number.\nStart with a special character.\n\nAnswer: B) Start with an uppercase letter.\n\nClass names in Java must:\n\n\nMatch the file name.\nBe different from the file name.\nBe the same as the package name.\nBe the same as the method name.\n\nAnswer: A) Match the file name.\n\nAll attributes and methods in Java classes must have:\n\n\nA return type.\nAn access modifier: public, private, or protected.\nA static keyword.\nA class keyword.\n\nAnswer: B) An access modifier: public, private, or protected.\n\nIn Java, which of the following is true for semicolons ;?\n\n\nSemicolons are used to mark the end of a block of code.\nSemicolons are used to separate statements in Java.\nSemicolons are used to define the start of a block of code.\nSemicolons are used to define the end of a method.\n\nAnswer: B) Semicolons are used to separate statements in Java.\n\nWhich of the following is True for curly braces {} in Java?\n\n\nCurly braces are used to define the start and end of a block of code.\nCurly braces are used to define the start and end of a method.\nCurly braces are used to define the start and end of a class.\nCurly braces are used to define the start and end of a loop.\nAll of the above\n\nAnswer: E) All of the above\n\npublic static void main(String[] args) is:\n\n\nA method that is executed first when a Java project is run.\nA method that is executed first when a Java class is instantiated.\nA method that is executed when a Java class is compiled\nA method that is executed when a Java class is imported\n\nAnswer: A) A method that is executed first when a Java project is run.\n\nvoid in Java is best described as:\n\n\nUsed to specify that a method does not return any value.\nSame as null in Java.\nUsed to specify that a method returns object of class the method is defined in.\nA valid data type for variables in Java.\n\nAnswer: A) Used to specify that a method does not return any value."
  },
  {
    "objectID": "basics/operations/tmp.html#primitive-data-types",
    "href": "basics/operations/tmp.html#primitive-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.1. Primitive Data Types",
    "text": "2.1. Primitive Data Types\n\nSort the following data types in Java from smallest to largest in terms of memory size:\n\n\nbyte, short, int, long\nlong, int, short, byte\nint, long, short, byte\nshort, byte, long, int\n\nAnswer: A) byte, short, int, long\n\ndouble in Java is a:\n\n\nA numeric primitive data type that stores integer numbers bigger than supported by int.\nA numeric primitive data type that stores floating-point numbers more precisely than float.\nA numeric primitive data type that stores integer numbers bigger than supported by long.\nA numeric primitive data type that stores floating-point numbers less precisely than float.\n\nAnswer: B) A numeric primitive data type that stores floating-point numbers more precisely than float.\n\nWhich of the following best describes char and String types in Java?\n\n\nchar is a primitive data type that stores a single character, while String is a reference type that stores a sequence of characters.\nchar is a reference type that stores a single character, while String is a primitive data type that stores a sequence of characters.\nchar and String are both primitive data types that store single characters.\nchar and String are both reference types that store sequences of characters.\n\nAnswer: A) char is a primitive data type that stores a single character, while String is a reference type that stores a sequence of characters.\n\nThere is no primitive data type in Java for strings like str in Python.\n\n\nTrue\nFalse\n\nAnswer: A) True\n\nConverting an int i = 4; to a long type can be done in Java using:\n\n\nlong l = (long) i;\nlong l = long(i);\nlong l = i.toLong();\nlong l = i;\n\nAnswer: A) long l = (long) i;\n\nint and Interger in Java are:\n\n\nThe same data type.\nDifferent data types.\nint is a primitive data type, and Integer is a wrapper class\nint is a wrapper class for the Integer primitive data type.\n\nAnswer: C) int is a primitive data type, and Integer is a wrapper class for the int primitive data type that allows it to be treated as an object.\n\nEvery primitive data type in Java has a corresponding wrapper class that allows\n\n\nThe primitive data type to be treated as an object.\nThe primitive data type to be used to be used in loops.\nThe primitive data type to be used as a return type in methods.\nThe primitive data type to be used in conditional statements.\n\nAnswer: A) The primitive data type to be treated as an object.\n\njava      int a = 10;     long b = 20;     float c = 30.0f;     double d = 40.0;     double result = a * b + c / d;\n\nIn the above code snippet, the data type of the result is determined by:\n\nThe data type of the variable a because it comes first.\nThe data type of the variable b because it is the largest integer.\nThe data type of the variable c because it is a floating-point number.\nThe data type of the variable d because it is most precise and the operand with the highest memory size.\n\nAnswer: D) The data type of the variable d."
  },
  {
    "objectID": "basics/operations/tmp.html#fixed-size-reference-data-types",
    "href": "basics/operations/tmp.html#fixed-size-reference-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.2. Fixed-Size Reference Data Types",
    "text": "2.2. Fixed-Size Reference Data Types\n\nThere are two types of data types in Java:\n\n\nStatic data types and dynamic data types.\nInteger data types and floating-point data types.\nPrimitive data types and reference data types.\nNone of the above\n\nAnswer: C) Primitive data types and reference data types.\n\nWhich of the following is a fixed-size reference data type in Java? Select all that apply.\n\n\nArrays\nUser-defined Classes\nStrings\nLinked Lists\n\nAnswer: A) Arrays and C) Strings\n\nWhich of the following best describes the difference between Arrays in Java and lists in Python? Select all that apply.\n\n\nArrays in Java are fixed in size, while lists in Python can grow or shrink dynamically.\nArrays in Java can store elements of different types, while lists in Python are homogeneous.\nArrays in Java are dynamically allocated, while lists in Python are statically allocated.\nArrays in Java are homogenous, while lists in Python can store elements of different types.\n\n\nWhich of the following is True about slicing in Java arrays? Select all that apply.\n\n\nJava arrays do not support slicing.\nJava arrays support slicing using the slice() method.\nJava arrays support slicing using the Arrays.copyOfRange() method.\nJava arrays support slicing using the [start:end] syntax.\n\nAnswer: C) Java arrays support slicing using the Arrays.copyOfRange() method.\n\nWhich of the following is the correct way to initialize an array of integers in Java? Select all that apply.\n\n\nint[] numbers = {10, 20, 30, 40, 50};\nint numbers[] = {10, 20, 30, 40, 50};\nint numbers[5] = {10, 20, 30, 40, 50};\nint numbers = {10, 20, 30, 40, 50};\n\nAnswer: A) int[] numbers = {10, 20, 30, 40, 50}; B) int numbers[] = {10, 20, 30, 40, 50};\n\nWhich of the following is the correct way to declare an array of five integers in Java? Select all that apply.\n\n\nint[] numbers = new int[5];\nint numbers[] = new int[5];\nint numbers[5] = new int[];\nint numbers = new int[5];\n\nAnswer: A) int[] numbers = new int[5];\nB) int numbers[] = new int[5];\n\nWhich of the following is the correct way to add values to an Array of integers in Java?\n\n\nnumbers.add(10);\nnumbers.append(20);\nnumbers.push(30);\nnumbers[0] = 40;\n\nAnswer: D) numbers[0] = 40;\n\nHow do you get the length of an array in Java?\n\n\nnumbers.size();\nnumbers.length();\nnumbers.size;\nnumbers.length;\n\nAnswer: D) numbers.length;\n\nWhich of the following is a correct way to initialize a String variable in Java? Select all that apply.\n\n\nString name = \"Alice\";\nString name = new String(\"Alice\");\nString name = 'Alice';\nString name = {\"Alice\"};\n\nAnswer: A) String name = \"Alice\"; and B) String name = new String(\"Alice\");\n\nWhich of the following is a correct way to compare two strings in Java? Select all that apply.\n\n\nname1 == name2;\nname1.equals(name2);\nname1.compare(name2);\nname1.compareTo(name2);\n\nAnswer: B) name1.equals(name2); and D) name1.compareTo(name2);\n\nWhich of the following is a correct way to concatenate two strings in Java? Select all that apply.\n\n\nname1 + name2;\nname1.concat(name2);\nname1.append(name2);\nname1.join(name2);\n\nAnswer: A) name1 + name2; and B) name1.concat(name2);\n\nStrings in Java are:\n\n\nMutable: Strings can be changed after they are created.\nImmutable: Strings cannot be changed after they are created.\nConditional: Strings can be changed as long as the new value is the same length.\nNone of the above\n\nAnswer: B) Immutable: Strings cannot be changed after they are created.\n\nConverting \"123\" of type String to an integer in Java can be done using:\n\n\nInteger.parseInt(\"123\");\nint.parse(\"123\");\nString.toInt(\"123\");\n(int) \"123\"\n\nAnswer: A) Integer.parseInt(\"123\");"
  },
  {
    "objectID": "basics/operations/tmp.html#dynamic-size-reference-data-types",
    "href": "basics/operations/tmp.html#dynamic-size-reference-data-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.3. Dynamic-Size Reference Data Types",
    "text": "2.3. Dynamic-Size Reference Data Types\n\nDoes Java support dynamic-size reference data types?\n\n\nYes, Java supports dynamic-size reference data types but not primitive data types and you have to import the java.util package to use them.\nNo, Java does not support dynamic-size reference data types and you must use fixed-size arrays.\n\n\nWhich of the following is true about dynamic-size reference data type in Java? Select all that apply.\n\n\nArrayList is a dynamic-size reference data type in Java and behaves analogously to Python lists.\nHashSet is a dynamic-size reference data type in Java that stores unique elements and behaves analogously to Python sets.\nHashMap is a dynamic-size reference data type in Java that stores key-value pairs and behaves analogously to Python dictionaries.\nAll of the above\n\nAnswer: D) All of the above"
  },
  {
    "objectID": "basics/operations/tmp.html#classes-user-defined-types",
    "href": "basics/operations/tmp.html#classes-user-defined-types",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "2.4. Classes: User Defined Types",
    "text": "2.4. Classes: User Defined Types\n\nstatic keyword in Java is best described as:\n\n\nUsed to specify that a method does not return any value.\nUsed to specify that a method is associated with the class rather than an instance of the class.\nUsed to specify that a method is associated with an instance of the class rather than the class itself.\nA valid data type for variables in Java.\n\nAnswer: B) Used to specify that a method is associated with the class rather than an instance of the class.\n\nfinal keyword in Java is best described as:\n\n\nUsed to specify that a variable or method is associated with the class rather than an instance of the class.\nUsed to specify that a variable or method cannot be changed or overridden.\nUsed to specify that a variable or method is associated with an instance of the class rather than the class itself.\nUsed to specify that a variable or method must never be accessed.\n\nAnswer: B) Used to specify that a variable or method cannot be changed or overridden."
  },
  {
    "objectID": "basics/operations/tmp.html#math-operators",
    "href": "basics/operations/tmp.html#math-operators",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.1. Math Operators",
    "text": "3.1. Math Operators"
  },
  {
    "objectID": "basics/operations/tmp.html#built-in-functions",
    "href": "basics/operations/tmp.html#built-in-functions",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.2. Built-in Functions",
    "text": "3.2. Built-in Functions"
  },
  {
    "objectID": "basics/operations/tmp.html#file-io",
    "href": "basics/operations/tmp.html#file-io",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.3. File I/O",
    "text": "3.3. File I/O"
  },
  {
    "objectID": "basics/operations/tmp.html#testing-in-java",
    "href": "basics/operations/tmp.html#testing-in-java",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "3.4. Testing in Java",
    "text": "3.4. Testing in Java"
  },
  {
    "objectID": "basics/operations/tmp.html#conditionals",
    "href": "basics/operations/tmp.html#conditionals",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.1. Conditionals",
    "text": "4.1. Conditionals"
  },
  {
    "objectID": "basics/operations/tmp.html#loops",
    "href": "basics/operations/tmp.html#loops",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.2. Loops",
    "text": "4.2. Loops"
  },
  {
    "objectID": "basics/operations/tmp.html#exception-handling",
    "href": "basics/operations/tmp.html#exception-handling",
    "title": "1. PROGRAMMING, IN JAVA",
    "section": "4.3. Exception Handling",
    "text": "4.3. Exception Handling\n\nConstructors in Java are defined as:\n\n\npublic void constructor()\npublic constructor()\npublic Constructor()\npublic ClassName()\n\nAnswer: D) public ClassName()\n\nWhich of the following is True about constructors in Java classes?\n\n\nA class in Java can have multiple constructors with different parameters.\nA class in Java can have multiple constructors with the same parameters.\nA class in Java can have only one constructor.\nA class in Java cannot have a constructor.\n\nAnswer: A) A class in Java can have multiple constructors with different parameters.\n\nWhich of the following is True about constructors in Java classes?\n\n\nA constructor must have the same name as the class with no return type.\nA constructor must have a different name than the class with a return type of void.\nA constructor must have a different name than the class with a return type of the class.\nA constructor must have the same name as the class with a return type of the class.\n\nAnswer: A) A constructor must have the same name as the class with no return type.\n\nAll methods in Java must have the following. Select all that apply.\n\n\nA return type\nAn access modifier: public, private, or protected\nA static keyword\nA class keyword\nA return type and B) An access modifier: public, private, or protected\n\n\nWhich of the following is True about the main method in Java?\n\n\nThe main method is required in every Java class.\nThe main method is executed first when a Java project is run.\nThe main method must have a return type of void.\nThe main method must be declared as public static void main(String[] args).\n\nAnswer: A) The main method is required in every Java class. B) The main method is executed first when a Java project is run. D) The main method must be declared as public static void main(String[] args).\n\nWhat is the keyword used for pointing to the current instance of the class in Java?\n\n\nnew\nself\nthis\nclass\n\nAnswer: C) this\n\nWhich of the following arithmetic operators is not supported in Java?\n\n\nModulus (%)\nFloor division (//)\nMultiplication (*)\nExponentiation (**)\n\nAnswer: D) Exponentiation (**) and Floor division (//) are not supported in Java.\n\nWhich of the following is the boolean and operator in Java?\n\n\n&\n&&\n^\nand\n\nAnswer: B) &&\n\nWhich of the following is true for System.out.println in Java?\n\n\nWe need to import the System class to use System.out.println.\nSystem.out.println is used to print output to the console.\nprintln is a method of the System.out class that prints a new line.\nAll of the above\n\nAnswer: D) All of the above\n\ntry and except in Python are equivalent to which of the following in Java?\n\n\ntry and catch\ntry and finally\ntry and throw\ntry and throws\n\nAnswer: A) try and catch"
  },
  {
    "objectID": "basics/operations/math_operators.html",
    "href": "basics/operations/math_operators.html",
    "title": "Math Operators",
    "section": "",
    "text": "The following table lists the arithmetic operators in Java. The first four operators are the basic arithmetic operators. The last two operators are the floor division and modulo operators, respectively.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n+\nAddition\n1 + 2\n3\n\n\n-\nSubtraction\n1 - 2\n-1\n\n\n*\nMultiplication\n1 * 2\n2\n\n\n/\nDivision\n1 / 2\n0.5\n\n\n//\nFloor Division\n1 // 2\n0\n\n\n%\nModulo\n1 % 2\n1\n\n\n\n\n\nPython and Java have some similarities in their use of mathematical operators, but there are notable differences in their behavior and usage. Here’s a comparison:\n\n\nBoth Python and Java use the same basic arithmetic operators: - Addition (+): Adds two operands. - Subtraction (-): Subtracts the second operand from the first. - Multiplication (*): Multiplies two operands. - Division (/): Divides the first operand by the second. - Modulus (%): Returns the remainder of a division operation.\n\n\n\n\nPython:\n\nThe / operator performs true division and always returns a float, even if both operands are integers.\nInteger division can be performed using the // operator, which returns the floor of the division.\n\n5 / 2   # Returns 2.5\n5 // 2  # Returns 2\nJava:\n\nThe / operator performs division, but the result depends on the operand types:\n\nIf both operands are integers, integer division is performed, and the result is an integer.\nIf either operand is a floating-point number (float or double), floating-point division is performed, returning a float or double.\n\nint result = 5 / 2;  // Returns 2 (integer division)\ndouble result = 5.0 / 2;  // Returns 2.5 (floating-point division)\n\n\n\n\n\n\nPython:\n\nPython has a built-in operator for exponentiation: **.\n\n2 ** 3  # Returns 8\nJava:\n\nJava does not have a built-in exponentiation operator. Instead, you use the Math.pow() method to perform exponentiation.\n\ndouble result = Math.pow(2, 3);  // Returns 8.0\n\n\n\n\n\nPython:\n\nSupports unary operators like + and - for positive and negative values.\n\nx = -5\ny = +5\nJava:\n\nJava also supports unary operators + and -, as well as the increment (++) and decrement (--) operators.\n\nint x = -5;\nint y = +5;\nint z = ++x;  // Increments x by 1, then assigns to z\n\n\n\n\n\nPython:\n\nThe % operator returns the remainder of a division operation. It handles both positive and negative numbers, with the result having the same sign as the divisor.\n\n5 % 3   # Returns 2\n-5 % 3  # Returns 1\nJava:\n\nThe % operator also returns the remainder, but the result has the same sign as the dividend.\n\n5 % 3   # Returns 2\n-5 % 3  # Returns -2",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#arithmetic-operators",
    "href": "basics/operations/math_operators.html#arithmetic-operators",
    "title": "Math Operators",
    "section": "",
    "text": "The following table lists the arithmetic operators in Java. The first four operators are the basic arithmetic operators. The last two operators are the floor division and modulo operators, respectively.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n+\nAddition\n1 + 2\n3\n\n\n-\nSubtraction\n1 - 2\n-1\n\n\n*\nMultiplication\n1 * 2\n2\n\n\n/\nDivision\n1 / 2\n0.5\n\n\n//\nFloor Division\n1 // 2\n0\n\n\n%\nModulo\n1 % 2\n1\n\n\n\n\n\nPython and Java have some similarities in their use of mathematical operators, but there are notable differences in their behavior and usage. Here’s a comparison:\n\n\nBoth Python and Java use the same basic arithmetic operators: - Addition (+): Adds two operands. - Subtraction (-): Subtracts the second operand from the first. - Multiplication (*): Multiplies two operands. - Division (/): Divides the first operand by the second. - Modulus (%): Returns the remainder of a division operation.\n\n\n\n\nPython:\n\nThe / operator performs true division and always returns a float, even if both operands are integers.\nInteger division can be performed using the // operator, which returns the floor of the division.\n\n5 / 2   # Returns 2.5\n5 // 2  # Returns 2\nJava:\n\nThe / operator performs division, but the result depends on the operand types:\n\nIf both operands are integers, integer division is performed, and the result is an integer.\nIf either operand is a floating-point number (float or double), floating-point division is performed, returning a float or double.\n\nint result = 5 / 2;  // Returns 2 (integer division)\ndouble result = 5.0 / 2;  // Returns 2.5 (floating-point division)\n\n\n\n\n\n\nPython:\n\nPython has a built-in operator for exponentiation: **.\n\n2 ** 3  # Returns 8\nJava:\n\nJava does not have a built-in exponentiation operator. Instead, you use the Math.pow() method to perform exponentiation.\n\ndouble result = Math.pow(2, 3);  // Returns 8.0\n\n\n\n\n\nPython:\n\nSupports unary operators like + and - for positive and negative values.\n\nx = -5\ny = +5\nJava:\n\nJava also supports unary operators + and -, as well as the increment (++) and decrement (--) operators.\n\nint x = -5;\nint y = +5;\nint z = ++x;  // Increments x by 1, then assigns to z\n\n\n\n\n\nPython:\n\nThe % operator returns the remainder of a division operation. It handles both positive and negative numbers, with the result having the same sign as the divisor.\n\n5 % 3   # Returns 2\n-5 % 3  # Returns 1\nJava:\n\nThe % operator also returns the remainder, but the result has the same sign as the dividend.\n\n5 % 3   # Returns 2\n-5 % 3  # Returns -2",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#comparison-operators",
    "href": "basics/operations/math_operators.html#comparison-operators",
    "title": "Math Operators",
    "section": "Comparison Operators",
    "text": "Comparison Operators\nThe following table lists the comparison operators in Java. These operators compare two operands and evaluate to either true or false.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n==\nEqual to\n1 == 1\ntrue\n\n\n!=\nNot equal to\n1 != 1\nfalse\n\n\n&gt;\nGreater than\n1 &gt; 1\nfalse\n\n\n&lt;\nLess than\n1 &lt; 1\nfalse\n\n\n&gt;=\nGreater than or equal to\n1 &gt;= 1\ntrue\n\n\n&lt;=\nLess than or equal to\n1 &lt;= 1\ntrue\n\n\n\n\nComparison with Python\n\nPython:\n\nComparison operators (&lt;, &lt;=, &gt;, &gt;=, ==, !=) can be used with numbers, strings, and other types.\nPython also supports chaining comparisons (e.g., 1 &lt; x &lt; 10).\n\nJava:\n\nComparison operators are used primarily with primitive types and do not support chaining like Python.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#logical-operators",
    "href": "basics/operations/math_operators.html#logical-operators",
    "title": "Math Operators",
    "section": "Logical Operators",
    "text": "Logical Operators\nThe following table lists the logical operators in Java. These operators combine two or more boolean expressions and evaluate to either true or false.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n&&\nLogical AND\ntrue && false\nfalse\n\n\n||\nLogical OR\ntrue || false\ntrue\n\n\n!\nLogical NOT\n!true\nfalse",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#membership-operators",
    "href": "basics/operations/math_operators.html#membership-operators",
    "title": "Math Operators",
    "section": "Membership Operators",
    "text": "Membership Operators\nThe following table lists the membership operators in Java. These operators test for membership in a sequence and evaluate to either true or false.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\nin\nMembership\n1 in [1, 2, 3]\ntrue\n\n\nnot in\nNegated Membership\n1 not in [1, 2, 3]\nfalse",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#identity-operators",
    "href": "basics/operations/math_operators.html#identity-operators",
    "title": "Math Operators",
    "section": "Identity Operators",
    "text": "Identity Operators\nThe following table lists the identity operators in Java. These operators compare the memory locations of two objects and evaluate to either true or false.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\nis\nIdentity\n1 is 1\ntrue\n\n\nis not\nNegated Identity\n1 is not 1\nfalse",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#assignment-operators",
    "href": "basics/operations/math_operators.html#assignment-operators",
    "title": "Math Operators",
    "section": "Assignment Operators",
    "text": "Assignment Operators\nWe have already seen the assignment operator = in the previous sections.\nThe assignment operator has many variations that combine assignment with another operator (primarily arithmetic operators).\nThe following table lists the assignment operators in Java.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n=\nAssign\na = 1\n1\n\n\n+=\nAdd and Assign\na += 1\n2\n\n\n-=\nSubtract and Assign\na -= 1\n0\n\n\n*=\nMultiply and Assign\na *= 2\n2\n\n\n/=\nDivide and Assign\na /= 2\n0.5\n\n\n//=\nFloor Divide and Assign\na //= 2\n0\n\n\n%=\nModulo and Assign\na %= 2\n1",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#bitwise-operators",
    "href": "basics/operations/math_operators.html#bitwise-operators",
    "title": "Math Operators",
    "section": "Bitwise Operators",
    "text": "Bitwise Operators\nThe following table lists the bitwise operators in Java. These operators perform bitwise operations on integers.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n&\nBitwise AND\n1 & 2\n0\n\n\n|\nBitwise OR\n1 | 2\n3\n\n\n^\nBitwise XOR\n1 ^ 2\n3\n\n\n~\nBitwise NOT\n~1\n-2\n\n\n&lt;&lt;\nLeft Shift\n1 &lt;&lt; 2\n4\n\n\n&gt;&gt;\nRight Shift\n4 &gt;&gt; 2\n1\n\n\n&gt;&gt;&gt;\nUnsigned Right Shift\n4 &gt;&gt;&gt; 2\n1",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/math_operators.html#operator-overloading",
    "href": "basics/operations/math_operators.html#operator-overloading",
    "title": "Math Operators",
    "section": "Operator Overloading",
    "text": "Operator Overloading\n\nPython:\n\nSupports operator overloading, allowing operators to be redefined for user-defined classes.\nExample: You can define how + behaves for a custom class.\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\nJava:\n\nDoes not support operator overloading. Operators have fixed behavior based on the data types they are used with.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Math Operators"
    ]
  },
  {
    "objectID": "basics/operations/builtinfuncs.html",
    "href": "basics/operations/builtinfuncs.html",
    "title": "Built-in Functions",
    "section": "",
    "text": "Java provides a set of built-in functions that perform common operations such as mathematical calculations, string manipulation, and input/output operations. These functions are part of the Java standard library and can be used directly in your programs. In this tutorial, we will learn about some of the most commonly used built-in functions in Java.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Built-in Functions"
    ]
  },
  {
    "objectID": "basics/operations/builtinfuncs.html#inputoutput-functions",
    "href": "basics/operations/builtinfuncs.html#inputoutput-functions",
    "title": "Built-in Functions",
    "section": "Input/Output Functions",
    "text": "Input/Output Functions\nJava provides a set of input/output functions that allow you to read data from the standard input, write data to the standard output, and perform file I/O operations. Here are some examples of input/output functions in Java:\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample\n\n\n\n\nSystem.out.println(x)\nPrints the value of x to the standard output\nSystem.out.println(\"Hello\") prints Hello\n\n\nSystem.in.read()\nReads a single character from the standard input\nchar c = (char) System.in.read() reads a character\n\n\n\nReading from the standard input using System.in.read() can be cumbersome, so Java provides the Scanner class to simplify input operations. Here is an example of reading an integer from the standard input using Scanner:\nimport java.util.Scanner;\n\npublic class ReadInput {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter an integer: \");\n        int num = scanner.nextInt();\n        System.out.println(\"You entered: \" + num);\n        scanner.close();\n    }\n}",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Built-in Functions"
    ]
  },
  {
    "objectID": "basics/operations/builtinfuncs.html#mathematical-functions",
    "href": "basics/operations/builtinfuncs.html#mathematical-functions",
    "title": "Built-in Functions",
    "section": "Mathematical Functions",
    "text": "Mathematical Functions\nJava provides a set of mathematical functions that allow you to perform common mathematical operations such as rounding, exponentiation, and trigonometry. Here are some examples of mathematical functions in Java:\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample\n\n\n\n\nMath.abs(x)\nReturns the absolute value of x\nMath.abs(-5) returns 5\n\n\nMath.pow(x, y)\nReturns x raised to the power of y\nMath.pow(2, 3) returns 8\n\n\nMath.sqrt(x)\nReturns the square root of x\nMath.sqrt(16) returns 4\n\n\nMath.round(x)\nRounds x to the nearest integer\nMath.round(3.5) returns 4\n\n\nMath.max(x, y)\nReturns the larger of x and y\nMath.max(10, 20) returns 20\n\n\nMath.min(x, y)\nReturns the smaller of x and y\nMath.min(10, 20) returns 10\n\n\nMath.sin(x)\nReturns the sine of x in radians\nMath.sin(Math.PI/2) returns 1.0\n\n\nMath.cos(x)\nReturns the cosine of x in radians\nMath.cos(0) returns 1.0\n\n\nMath.tan(x)\nReturns the tangent of x in radians\nMath.tan(Math.PI/4) returns 1.0",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Built-in Functions"
    ]
  },
  {
    "objectID": "basics/operations/builtinfuncs.html#string-functions",
    "href": "basics/operations/builtinfuncs.html#string-functions",
    "title": "Built-in Functions",
    "section": "String Functions",
    "text": "String Functions\nJava provides a set of string functions that allow you to manipulate strings in various ways. Here are some examples of string functions in Java:\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample\n\n\n\n\nstr.length()\nReturns the length of the string str\n\"Hello\".length() returns 5\n\n\nstr.charAt(index)\nReturns the character at the specified index\n\"Hello\".charAt(0) returns H\n\n\nstr.substring(start)\nReturns a substring starting from start index\n\"Hello\".substring(1) returns ello\n\n\nstr.indexOf(substr)\nReturns the index of the first occurrence of substr\n\"Hello\".indexOf(\"l\") returns 2\n\n\nstr.toUpperCase()\nConverts the string to uppercase\n\"hello\".toUpperCase() returns HELLO\n\n\nstr.toLowerCase()\nConverts the string to lowercase\n\"HELLO\".toLowerCase() returns hello\n\n\n\nStringBuilder and StringBuffer classes are used to create mutable strings in Java. These classes provide methods for appending, inserting, deleting, and modifying string content.\nSome commonly used methods of StringBuilder and StringBuffer classes are:\n\n\n\n\n\n\n\n\nMethod\nDescription\nExample\n\n\n\n\nappend(str)\nAppends the string str to the StringBuilder\nsb.append(\"Hello\") appends Hello\n\n\ninsert(index, str)\nInserts the string str at the specified index\nsb.insert(0, \"World\") inserts World at the beginning\n\n\ndelete(start, end)\nDeletes the characters from start to end\nsb.delete(0, 5) deletes characters from 0 to 4\n\n\nreverse()\nReverses the characters in the StringBuilder\nsb.reverse() reverses the content",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Built-in Functions"
    ]
  },
  {
    "objectID": "basics/controls/loops.html",
    "href": "basics/controls/loops.html",
    "title": "Loops",
    "section": "",
    "text": "Loops in Java are used to execute a block of code repeatedly. They allow you to iterate over a sequence of elements or execute a block of code until a certain condition is met. In this tutorial, we will learn about loops in Java.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/loops.html#for-loop",
    "href": "basics/controls/loops.html#for-loop",
    "title": "Loops",
    "section": "for Loop",
    "text": "for Loop\nThe for loop is used to iterate over a sequence of elements a fixed number of times. It consists of three parts: initialization, condition, and increment/decrement. The basic syntax of the for loop is as follows:\nfor (initialization; condition; increment/decrement) {\n    // code block to be executed\n}\nHere is an example of using the for loop to print numbers from 1 to 5:\nfor (int i = 1; i &lt;= 5; i++) {\n    System.out.println(i);\n}\nIn the above example, the for loop iterates over the numbers from 1 to 5 and prints each number to the console.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/loops.html#while-loop",
    "href": "basics/controls/loops.html#while-loop",
    "title": "Loops",
    "section": "while Loop",
    "text": "while Loop\nThe while loop is used to execute a block of code repeatedly as long as a specified condition is true. The loop continues to execute until the condition becomes false. The basic syntax of the while loop is as follows:\nwhile (condition) {\n    // code block to be executed\n}\nHere is an example of using the while loop to print numbers from 1 to 5:\n\nint i = 1;\n\nwhile (i &lt;= 5) {\n    System.out.println(i);\n    i++;\n}\nIn the above example, the while loop iterates over the numbers from 1 to 5 and prints each number to the console.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/loops.html#do-while-loop",
    "href": "basics/controls/loops.html#do-while-loop",
    "title": "Loops",
    "section": "do-while Loop",
    "text": "do-while Loop\nThe do-while loop is similar to the while loop, but the condition is checked after the block of code is executed. This means that the block of code is executed at least once, even if the condition is false. The basic syntax of the do-while loop is as follows:\ndo {\n    // code block to be executed\n} while (condition);\nHere is an example of using the do-while loop to print numbers from 1 to 5:\nint i = 1;\n\ndo {\n    System.out.println(i);\n    i++;\n} while (i &lt;= 5);\nIn the above example, the do-while loop iterates over the numbers from 1 to 5 and prints each number to the console.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/loops.html#loop-control-statements",
    "href": "basics/controls/loops.html#loop-control-statements",
    "title": "Loops",
    "section": "Loop Control Statements",
    "text": "Loop Control Statements\nJava provides loop control statements that allow you to control the flow of the loop. The loop control statements include break, continue, and return.\n\nbreak Statement\nThe break statement is used to exit the loop prematurely. It is often used to terminate the loop when a certain condition is met. When the break statement is encountered, the loop is terminated, and the control is transferred to the statement following the loop.\nHere is an example of using the break statement to exit a loop when the value of i is 3:\n\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        break;\n    }\n    System.out.println(i);\n}\nIn the above example, the loop is terminated when the value of i is 3.\n\n\ncontinue Statement\nThe continue statement is used to skip the current iteration of the loop and continue with the next iteration. It is often used to skip certain elements in the loop based on a condition.\nHere is an example of using the continue statement to skip printing even numbers:\n\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i % 2 == 0) {\n        continue;\n    }\n    System.out.println(i);\n}\nIn the above example, the loop skips printing even numbers using the continue statement.\n\n\nreturn Statement\nThe return statement is used to exit a method prematurely. When the return statement is encountered inside a loop, the loop is terminated, and the control is transferred back to the caller of the method.\nHere is an example of using the return statement inside a loop:\n\npublic void printNumbers() {\n    for (int i = 1; i &lt;= 5; i++) {\n        if (i == 3) {\n            return;\n        }\n        System.out.println(i);\n    }\n}\nIn the above example, the loop is terminated when the value of i is 3 using the return statement.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/loops.html#nested-loops",
    "href": "basics/controls/loops.html#nested-loops",
    "title": "Loops",
    "section": "Nested Loops",
    "text": "Nested Loops\nNested loops are loops inside another loop. They are used to perform repetitive tasks that require multiple levels of iteration. Nested loops can be of any type, such as for, while, or do-while.\nHere is an example of using nested loops to print a pattern:\n\nfor (int i = 1; i &lt;= 5; i++) {\n    for (int j = 1; j &lt;= i; j++) {\n        System.out.print(\"* \");\n    }\n    System.out.println();\n}\nIn the above example, the nested loops are used to print a pattern of stars.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Loops"
    ]
  },
  {
    "objectID": "basics/controls/exceptions.html",
    "href": "basics/controls/exceptions.html",
    "title": "Exception Handling",
    "section": "",
    "text": "An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When an exception occurs, the program terminates abruptly, and the control is transferred to the exception handler.\nIn Java, exceptions are objects that represent an abnormal condition or error. Exceptions can occur due to various reasons, such as invalid input, file not found, network issues, arithmetic errors, etc.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Exception Handling"
    ]
  },
  {
    "objectID": "basics/controls/exceptions.html#types-of-exceptions",
    "href": "basics/controls/exceptions.html#types-of-exceptions",
    "title": "Exception Handling",
    "section": "Types of Exceptions",
    "text": "Types of Exceptions\nJava exceptions are divided into two categories: checked exceptions and unchecked exceptions.\nIn Java, exceptions are organized in a hierarchy of classes. The Throwable class is the superclass of all exceptions and errors in Java. The Exception class is a subclass of Throwable and is the superclass of all checked exceptions. The RuntimeException class is a subclass of Exception and is the superclass of all unchecked exceptions.\n\n\n\n\nChecked Exceptions\nChecked exceptions are exceptions that are checked at compile time. These exceptions are subclasses of the Exception class but not subclasses of the RuntimeException class. Checked exceptions must be caught or declared in the method signature using the throws keyword.\nExamples of checked exceptions include IOException, SQLException, ClassNotFoundException, etc.\n\n\nUnchecked Exceptions\nUnchecked exceptions are exceptions that are not checked at compile time. These exceptions are subclasses of the RuntimeException class. Unchecked exceptions do not need to be caught or declared in the method signature.\nExamples of unchecked exceptions include ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, etc.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Exception Handling"
    ]
  },
  {
    "objectID": "basics/controls/exceptions.html#exception-handling-in-java",
    "href": "basics/controls/exceptions.html#exception-handling-in-java",
    "title": "Exception Handling",
    "section": "Exception Handling in Java",
    "text": "Exception Handling in Java\nJava provides a robust exception handling mechanism to deal with exceptions. The try, catch, and finally blocks are used to handle exceptions in Java.\n\ntry Block\nThe try block is used to enclose the code that might throw an exception. It is followed by one or more catch blocks and an optional finally block.\n\n\ncatch Block\nThe catch block is used to handle the exception that is thrown in the try block. It contains the code that handles the exception. A try block can have multiple catch blocks to handle different types of exceptions.\n\n\nfinally Block\nThe finally block is used to execute the code that should be run regardless of whether an exception is thrown or not. It is executed after the try block and any associated catch blocks.\n\n\nExample of Exception Handling\nHere is an example of exception handling in Java:\npublic class ExceptionHandlingExample {\n    public static void main(String[] args) {\n        try {\n            int result = divide(10, 0);\n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Finally block executed.\");\n        }\n    }\n\n    public static int divide(int a, int b) {\n        return a / b;\n    }\n}\nIn this example, the divide method throws an ArithmeticException when dividing by zero. The exception is caught in the catch block, and the finally block is executed regardless of whether an exception occurs or not.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Exception Handling"
    ]
  },
  {
    "objectID": "basics/controls/exceptions.html#custom-exceptions",
    "href": "basics/controls/exceptions.html#custom-exceptions",
    "title": "Exception Handling",
    "section": "Custom Exceptions",
    "text": "Custom Exceptions\nIn addition to the built-in exceptions provided by Java, you can create your own custom exceptions by extending the Exception class or one of its subclasses. Custom exceptions are useful for handling application-specific errors or conditions.\nHere is an example of a custom exception:\npublic class CustomExceptionExample {\n    public static void main(String[] args) {\n        try {\n            throw new CustomException(\"Custom exception message\");\n        } catch (CustomException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\nclass CustomException extends Exception {\n    public CustomException(String message) {\n        super(message);\n    }\n}\nIn this example, we define a custom exception CustomException that extends the Exception class. We then throw this custom exception and catch it in the main method.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Control Flow",
      "Exception Handling"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html",
    "href": "basics/abstractions/classes.html",
    "title": "Classes: User Defined Types",
    "section": "",
    "text": "Classes in Java are the blueprints for objects. They define the structure and behavior of objects. A class is a template for objects, and an object is an instance of a class. In this tutorial, we will learn about classes in Java.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#declaring-a-class",
    "href": "basics/abstractions/classes.html#declaring-a-class",
    "title": "Classes: User Defined Types",
    "section": "Declaring a Class",
    "text": "Declaring a Class\nA class in Java is declared using the class keyword followed by the class name. The class name should start with an uppercase letter. Here is an example of a class declaration\npublic class Person {\n    // class members\n}\nIn the above example, we have declared a class named Person. The class body is enclosed within curly braces {}. The class body contains class members such as fields, methods, constructors, and nested classes.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#class-members",
    "href": "basics/abstractions/classes.html#class-members",
    "title": "Classes: User Defined Types",
    "section": "Class Members",
    "text": "Class Members\nA class can have the following members:\n\nAttributes (aka Fields): These are variables declared inside a class. They represent the state of an object.\nMethods: Methods are functions defined inside a class. They represent the behavior of an object.\nConstructors: Constructors are special methods used to initialize objects.\nNested Classes: A class can be defined inside another class. These are called nested classes.\n\n\n\n\n\nLet’s see an example of a class with fields, methods, and a constructor.\npublic class Person {\n    // fields\n    private String name;\n    private int age;\n\n    // constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // method\n    public void display() {\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n    }\n}\nIn the above example, we have defined a class Person with two fields name and age, a constructor that initializes the fields, and a method display that prints the name and age of the person.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#creating-objects",
    "href": "basics/abstractions/classes.html#creating-objects",
    "title": "Classes: User Defined Types",
    "section": "Creating Objects",
    "text": "Creating Objects\nTo create an object of a class, we use the new keyword followed by the class name and constructor arguments. Here is an example of creating an object of the Person class.\npublic class Main {\n    public static void main(String[] args) {\n        // create an object of Person class\n        Person person = new Person(\"Alice\", 30);\n\n        // call the display method\n        person.display();\n    }\n}\nIn the above example, we have created an object person of the Person class using the constructor with arguments \"Alice\" and 30. We then called the display method on the object to print the name and age of the person.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#attributes",
    "href": "basics/abstractions/classes.html#attributes",
    "title": "Classes: User Defined Types",
    "section": "Attributes",
    "text": "Attributes\nAttributes are variables declared inside a class. They represent the state of an object. Attributes are also known as fields.\nThe types of attributes are:\n\nInstance Variables: These are non-static variables declared inside a class. Each object of the class has its own copy of instance variables.\nStatic Variables: These are class-level variables declared with the static keyword. They are shared among all objects of the class.\nFinal Variables: These are constants declared with the final keyword. Their value cannot be changed once initialized.\n\n\nInstance Attributes\nInstance attributes are non-static variables declared inside a class. Each object of the class has its own copy of instance attributes. Here is an example of instance attributes in a class.\npublic class Person {\n    // instance variables\n    private String name;\n    private int age;\n}\nIn the above example, name and age are instance attributes of the Person class.\n\n\nStatic Attributes\nStatic attributes are class-level variables declared with the static keyword. They are shared among all objects of the class. Here is an example of static attributes in a class.\npublic class Counter {\n    // static variable\n    private static int count = 0;\n}\nIn the above example, count is a static attribute of the Counter class.\n\n\nFinal Attributes\nFinal attributes are constants declared with the final keyword. Their value cannot be changed once initialized. Here is an example of final attributes in a class.\npublic class Constants {\n    // final variable\n    public static final double PI = 3.14159;\n}\nIn the above example, PI is a final attribute of the Constants class.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#methods",
    "href": "basics/abstractions/classes.html#methods",
    "title": "Classes: User Defined Types",
    "section": "Methods",
    "text": "Methods\nMethods are functions defined inside a class. They represent the behavior of an object. Methods can be of two types:\n\nInstance Methods: These methods operate on the instance variables of the class. They are called on objects of the class.\nStatic Methods: These methods are declared with the static keyword. They can access only static variables of the class.\n\n\nInstance Methods\nInstance methods operate on the instance variables of the class. They are called on objects of the class. Here is an example of an instance method in a class.\npublic class Person {\n    // instance method\n    public void display() {\n        System.out.println(\"Displaying person information\");\n    }\n}\nIn the above example, display is an instance method of the Person class.\n\n\nStatic Methods\nStatic methods are declared with the static keyword. They can access only static variables of the class. Here is an example of a static method in a class.\npublic class MathUtils {\n    // static method\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\nIn the above example, add is a static method of the MathUtils class.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#constructors",
    "href": "basics/abstractions/classes.html#constructors",
    "title": "Classes: User Defined Types",
    "section": "Constructors",
    "text": "Constructors\nConstructors are special methods used to initialize objects. They have the same name as the class and do not have a return type. Constructors are called when an object is created using the new keyword.\n\nDefault Constructor\nIf a class does not have any constructor defined, Java provides a default constructor that initializes the object with default values. Here is an example of a default constructor.\npublic class Person {\n    // default constructor\n    public Person() {\n        System.out.println(\"Person object created\");\n    }\n}\nIn the above example, Person class has a default constructor that prints a message when a Person object is created.\n\n\nParameterized Constructor\nA parameterized constructor is a constructor with parameters. It is used to initialize the object with the specified values. Here is an example of a parameterized constructor.\npublic class Person {\n    // fields\n    private String name;\n    private int age;\n\n    // parameterized constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\nIn the above example, Person class has a parameterized constructor that initializes the name and age fields of the object.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/classes.html#this-keyword",
    "href": "basics/abstractions/classes.html#this-keyword",
    "title": "Classes: User Defined Types",
    "section": "this Keyword",
    "text": "this Keyword\nThe this keyword in Java is a reference to the current object. It is used to refer to the current instance of the class. The this keyword is used to differentiate between instance variables and parameters with the same name.\nThe this keyword is used to access instance variables and methods of the current object. Here is an example of using the this keyword.\npublic class Person {\n    // fields\n    private String name;\n    private int age;\n\n    // constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // method\n    public void display() {\n        System.out.println(\"Name: \" + this.name);\n        System.out.println(\"Age: \" + this.age);\n    }\n}\nNote that this is similar to very similar to self in Python.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Classes: User Defined Types"
    ]
  },
  {
    "objectID": "basics/abstractions/functions.html",
    "href": "basics/abstractions/functions.html",
    "title": "Functions",
    "section": "",
    "text": "Functions in Java are blocks of code that perform a specific task. They are used to break down the program into smaller and modular pieces. Functions help in organizing the code and making it more readable and maintainable. In this tutorial, we will learn about functions in Java."
  },
  {
    "objectID": "basics/abstractions/functions.html#declaring-a-function",
    "href": "basics/abstractions/functions.html#declaring-a-function",
    "title": "Functions",
    "section": "Declaring a Function",
    "text": "Declaring a Function\nA function in Java is declared using the static keyword followed by the return type, function name, and parameters. The return type specifies the type of value that the function will return. If the function does not return any value, the return type is void. Here is an example of a function declaration:\npublic static int add(int a, int b) {\n    return a + b;\n}"
  },
  {
    "objectID": "basics/abstractions/abstractions.html",
    "href": "basics/abstractions/abstractions.html",
    "title": "Abstractions",
    "section": "",
    "text": "Abstraction is the process of hiding the complex implementation details and showing only the necessary features of an object. In other words, it helps to reduce programming complexity and effort.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions"
    ]
  },
  {
    "objectID": "basics/abstractions/abstractions.html#why-abstraction",
    "href": "basics/abstractions/abstractions.html#why-abstraction",
    "title": "Abstractions",
    "section": "Why Abstraction?",
    "text": "Why Abstraction?\n\nReduce Complexity: Abstraction helps to reduce programming complexity and effort.\nSecurity: It helps to hide the internal details of an object and show only the necessary features of an object.\nCode Reusability: Abstraction helps to reuse the code and use it in multiple places.\nFlexibility: It helps to change the implementation of an object without affecting the rest of the code.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions"
    ]
  },
  {
    "objectID": "basics/abstractions/abstractions.html#programming-abstractions",
    "href": "basics/abstractions/abstractions.html#programming-abstractions",
    "title": "Abstractions",
    "section": "Programming Abstractions",
    "text": "Programming Abstractions\nIn programming, abstraction is achieved using three main concepts:\n\nData and Variables: Variables are used to store data values. They are used to represent the state of an object. They allow abstracting operations and algorithms from the specific values they operate on.\nFunctions and Methods: Functions and methods are used to define abstract behavior only in terms of inputs and outputs. They also allow abstracting the implementation details of an algorithm.\nClasses and Objects: Classes and objects are used to define abstract data types. They allow abstracting the data structure and behavior of an object.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures.html",
    "href": "basics/abstractions/datastructures.html",
    "title": "Fixed-Size Reference Data Types",
    "section": "",
    "text": "Java also has non-primitive data types, which are called reference types. These include:\nReference types store references (memory addresses) to objects rather than the objects themselves. This allows Java to manage memory more efficiently and handle complex data structures.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Fixed-Size Reference Data Types"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures.html#arrays",
    "href": "basics/abstractions/datastructures.html#arrays",
    "title": "Fixed-Size Reference Data Types",
    "section": "Arrays",
    "text": "Arrays\n\nAn array is a collection of elements of the same type stored in contiguous memory locations.\nArrays in Java are fixed in size, meaning the number of elements in an array is determined when the array is created and cannot be changed.\nArrays are indexed starting from 0. The index represents the position of an element in the array.\nTo access an element in an array, you use the index enclosed in square brackets after the array name (e.g., arr[0]).\n\nAn example of creating and accessing elements in an array:\nint[] arr = new int[5]; // Create an array of 5 integers\narr[0] = 10; // Assign 10 to the first element\narr[1] = 20; // Assign 20 to the second element\nSystem.out.println(arr[0]); // Output: 10\nSystem.out.println(arr[1]); // Output: 20\nNote that arrays are different from Python lists, which can grow or shrink dynamically and don’t need to have length specified at the time of creation. Also, Python lists can contain elements of different types, while Java arrays are homogeneous (contain elements of the same type).\nTo modify the values of an array, you can assign new values to individual elements using their indices.\nTo access subarrays or slices of an array, you can use the Arrays.copyOfRange() method or loop through the array and copy elements to a new array.\nAn array is a fixed-size collection of elements of the same type stored in contiguous memory locations. Arrays in Java are indexed starting from 0, and the index represents the position of an element in the array. The size of an array is determined when the array is created and cannot be changed.\n\nDeclaring and Initializing Arrays\nTo declare an array in Java, you specify the type of elements the array will hold, followed by square brackets [] and the array name. You can initialize the array with values using an array initializer enclosed in curly braces {}.\nHere is an example of declaring and initializing an array of integers:\n// Declare and initialize an array of integers\nint[] numbers = {10, 20, 30, 40, 50};\nIn the above example, we declared an array numbers of integers and initialized it with five elements.\n\n\nAccessing Array Elements\nYou can access elements in an array using the index enclosed in square brackets [] after the array name. The index starts from 0 for the first element and increments by 1 for each subsequent element.\nHere is an example of accessing elements in an array:\nint[] numbers = {10, 20, 30, 40, 50};\n\n// Access the first element\nint firstElement = numbers[0]; // firstElement = 10\n\n// Access the third element\nint thirdElement = numbers[2]; // thirdElement = 30\n\n\nArray Length\nYou can get the length of an array using the length property of the array. The length property returns the number of elements in the array.\nHere is an example of getting the length of an array:\nint[] numbers = {10, 20, 30, 40, 50};\n\n// Get the length of the array\nint length = numbers.length; // length = 5\n\n\nIterating Over Arrays\nYou can iterate over the elements of an array using a loop, such as a for loop or a foreach loop. By iterating over the array, you can access and process each element in the array.\nHere is an example of iterating over an array using a for loop:\n\nint[] numbers = {10, 20, 30, 40, 50};\n\n// Iterate over the array using a for loop\n\nfor (int i = 0; i &lt; numbers.length; i++) {\n    System.out.println(numbers[i]); // Output each element\n}\nIn the above example, we used a for loop to iterate over the numbers array and print each element to the console.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Fixed-Size Reference Data Types"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures.html#strings",
    "href": "basics/abstractions/datastructures.html#strings",
    "title": "Fixed-Size Reference Data Types",
    "section": "Strings",
    "text": "Strings\nIn Java, strings are objects of the String class that represent sequences of characters. Strings in Java are immutable, meaning their values cannot be changed once they are created. Java provides a rich set of methods for working with strings, such as concatenation, substring extraction, searching, and more.\nStrings are part of the Java standard library and do not need to be imported explicitly. You can create strings using string literals or the String class constructor.\n\nCreating Strings\nYou can create strings in Java using string literals or the String class constructor\nHere is an example of creating strings:\n// Using string literals\nString str1 = \"Hello, World!\";\nString str2 = \"Java Programming\";\n\n// Using the String class constructor\nString str3 = new String(\"Welcome to Java!\");\nIn the above example, we created strings using string literals and the String class constructor.\n\n\nRead String Length\nYou can get the length of a string using the length() method of the String class. The length() method returns the number of characters in the string.\nHere is an example of getting the length of a string:\nString str = \"Hello, World!\";\nint length = str.length(); // length = 13\n\n\nAccessing Characters\nIn order to read an individual character from a string, you can use the charAt() method. The charAt() method returns the character at a specified index in the string.\nHere is an example of accessing characters in a string:\nString str = \"Java Programming\";\nchar firstChar = str.charAt(0); // firstChar = 'J'\nchar lastChar = str.charAt(str.length() - 1); // lastChar = 'g'\n\n\nSubstring Extraction\nYou can extract a substring from a string using the substring() method. The substring() method takes the starting index and optionally the ending index of the substring to be extracted.\nHere is an example of extracting a substring from a string:\nString str = \"Hello, World!\";\nString subStr = str.substring(7); // subStr = \"World!\"\n\n\nString Concatenation\nYou can concatenate strings in Java using the + operator or the concat() method of the String class.\nHere is an example of concatenating strings:\nString str1 = \"Hello, \";\nString str2 = \"World!\";\nString result = str1 + str2; // result = \"Hello, World!\"\n\n\nString Comparison\nYou can compare strings in Java using the equals() method or the compareTo() method of the String class. The equals() method checks if two strings have the same content, while the compareTo() method compares two strings lexicographically.\nHere is an example of comparing strings:\nString str1 = \"Hello\";\nString str2 = \"Hello\";\nboolean isEqual = str1.equals(str2); // isEqual = true\nint result = str1.compareTo(\"World\"); // result = -15\n\n\nConverting to Numeric Types\nYou can convert strings to numeric types such as integers and doubles using the parseInt() and parseDouble() methods of the Integer and Double classes, respectively.\nHere is an example of converting a string to an integer:\nString str = \"123\";\nint number = Integer.parseInt(str); // number = 123\nIn the above example, we converted the string \"123\" to an integer using the parseInt() method of the Integer class.\n\n\nString Formatting\nYou can format strings in Java using the String.format() method, which allows you to create formatted strings with placeholders for variables.\nHere is an example of formatting a string:\nString name = \"Alice\";\nint age = 30;\nString message = String.format(\"Hello, %s! You are %d years old.\", name, age);\n// message = \"Hello, Alice! You are 30 years old.\"",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Fixed-Size Reference Data Types"
    ]
  },
  {
    "objectID": "basics/abstractions/datastructures.html#enums",
    "href": "basics/abstractions/datastructures.html#enums",
    "title": "Fixed-Size Reference Data Types",
    "section": "Enums",
    "text": "Enums\nAn enum in Java is a special data type that defines a set of constants. Enums are used to represent fixed values that are known at compile time. Enum constants are implicitly static and final, meaning they cannot be changed once they are defined.\nEnums are defined using the enum keyword, followed by the enum name and a list of constants enclosed in curly braces {}. Each constant is separated by a comma.\nHere is an example of defining an enum:\nenum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\nIn the above example, we defined an enum Day with constants representing the days of the week.\nEnums can have fields, constructors, and methods like classes. You can also define custom fields and methods for each enum constant.\nHere is an example of an enum with custom fields and methods:\n\nenum Day {\n    MONDAY(\"Monday\", 1),\n    TUESDAY(\"Tuesday\", 2),\n    WEDNESDAY(\"Wednesday\", 3),\n    THURSDAY(\"Thursday\", 4),\n    FRIDAY(\"Friday\", 5),\n    SATURDAY(\"Saturday\", 6),\n    SUNDAY(\"Sunday\", 7);\n\n    private final String name;\n    private final int value;\n\n    Day(String name, int value) {\n        this.name = name;\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\nIn the above example, we defined an enum Day with custom fields name and value for each constant. We also defined a constructor to initialize the fields and methods to access the fields.\nEnums are useful for representing a fixed set of values and can improve code readability and maintainability by providing meaningful names for constants.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Abstractions",
      "Fixed-Size Reference Data Types"
    ]
  },
  {
    "objectID": "datastructs/graphs_kruskal.html",
    "href": "datastructs/graphs_kruskal.html",
    "title": "Kruskal’s Algorithm",
    "section": "",
    "text": "Kruskal’s algorithm is a greedy algorithm that finds a minimum spanning tree for a connected graph. The algorithm builds the MST by adding edges one at a time, starting with the smallest edge and adding the next smallest edge that does not form a cycle in the tree.\n\n\n\n\nKruskal’s Algorithm Visualization\n\n\n\n\n  \n\n\nPsuedocode\nAlgorithm \\(\\text{Kruskal}(G)\\):\nInput: An undirected, weighted, connected graph \\(G\\) with \\(n\\) vertices and \\(m\\) edges\nOutput: A minimum spanning tree \\(T\\) for \\(G\\)\n\nSort all the edges in non-decreasing order of their weight.\nInitialize an empty graph \\(T\\) to store the MST.\nfor each edge \\(e\\) in the sorted list of edges do\n\nif adding edge \\(e\\) does not form a cycle in \\(T\\) then\n\nadd edge \\(e\\) to \\(T\\)\n\n\nreturn \\(T\\)\n\n\n\nAnalysis\nThe time complexity of Kruskal’s algorithm is O(E log E), where E is the number of edges in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees",
      "Kruskal's Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graphs_spanning.html",
    "href": "datastructs/graphs_spanning.html",
    "title": "Minimum Spanning Trees",
    "section": "",
    "text": "A spanning tree of a connected graph \\(G(V, E)\\) is a subgraph \\(G'\\), containing all the vertices \\(V\\) and a subset of the edges \\(E\\), that is a tree and connects all the vertices together.\nFormally, \\(G'(V, E')\\) is a spanning tree of \\(G(V, E)\\) if \\(E' \\subseteq E\\) and \\(G'\\) is a tree.\n\n\n\n\nThe number of edges in a spanning tree is always \\(V - 1\\), where \\(V\\) is the number of vertices in the graph.\nNote that the key distinction between trees and graphs is that trees are acyclic, while graphs can have cycles. Therefore, by definition, a spanning tree must be acyclic and connected (i.e., there is a path between every pair of vertices).\nSpanning Tree is not defined for disconnected graphs.\nNote that a graph can have multiple spanning trees, depending on which edges are included in the subgraph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees"
    ]
  },
  {
    "objectID": "datastructs/graphs_spanning.html#spanning-tree",
    "href": "datastructs/graphs_spanning.html#spanning-tree",
    "title": "Minimum Spanning Trees",
    "section": "",
    "text": "A spanning tree of a connected graph \\(G(V, E)\\) is a subgraph \\(G'\\), containing all the vertices \\(V\\) and a subset of the edges \\(E\\), that is a tree and connects all the vertices together.\nFormally, \\(G'(V, E')\\) is a spanning tree of \\(G(V, E)\\) if \\(E' \\subseteq E\\) and \\(G'\\) is a tree.\n\n\n\n\nThe number of edges in a spanning tree is always \\(V - 1\\), where \\(V\\) is the number of vertices in the graph.\nNote that the key distinction between trees and graphs is that trees are acyclic, while graphs can have cycles. Therefore, by definition, a spanning tree must be acyclic and connected (i.e., there is a path between every pair of vertices).\nSpanning Tree is not defined for disconnected graphs.\nNote that a graph can have multiple spanning trees, depending on which edges are included in the subgraph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees"
    ]
  },
  {
    "objectID": "datastructs/graphs_spanning.html#minimum-spanning-tree",
    "href": "datastructs/graphs_spanning.html#minimum-spanning-tree",
    "title": "Minimum Spanning Trees",
    "section": "Minimum Spanning Tree",
    "text": "Minimum Spanning Tree\nA minimum spanning tree (MST) of a connected graph is a subgraph that is a tree and connects all the vertices together with the minimum possible total edge weight.\nFormally, MST of a graph \\(G(V, E)\\) is a spanning tree \\(G'(V, E')\\) such that the sum of the weights of the edges \\(\\sum_{e \\in E'} w(e)\\) is minimized.\nFor a graph with $ |V| = n $ vertices, the MST will have $ n - 1 $ edges.\nMST is not unique, and a graph can have multiple MSTs if there are multiple edges with the same weight.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees"
    ]
  },
  {
    "objectID": "datastructs/graphs_spanning.html#cut-property",
    "href": "datastructs/graphs_spanning.html#cut-property",
    "title": "Minimum Spanning Trees",
    "section": "Cut Property",
    "text": "Cut Property\nThe cut property is a key property that helps in understanding the construction of minimum spanning trees.\nGiven a graph \\(G(V, E)\\) and a partition of the vertices \\(V\\) into two sets \\(S_1\\) and \\(S_2\\), a cut is a set of edges that have one endpoint in \\(S_1\\) and the other endpoint in \\(S_2\\).\n\n\n\n\nFor any cut \\((S_1, S_2)\\) of the graph, if an edge \\(e\\) has the minimum weight among all the edges that cross the cut, then this edge \\(e\\) must be part of the minimum spanning tree of the graph.\n\n\n\n\nThis property is crucial in the design of algorithms for finding minimum spanning trees, such as Kruskal’s algorithm and Prim’s algorithm.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees"
    ]
  },
  {
    "objectID": "datastructs/graphs_spanning.html#applications",
    "href": "datastructs/graphs_spanning.html#applications",
    "title": "Minimum Spanning Trees",
    "section": "Applications",
    "text": "Applications\n\nNetwork Design and Routing: Finding the minimum cost network that connects all the nodes. For example, laying cables to connect all houses with minimum cost or designing a circuit with minimum cost that connects all components.\n\n\n \n\n\n\nCluster Analysis and Image Segmentation: The minimum spanning tree can be used to identify clusters of data points, where the edges represent say euclidean distance between points. The tree can be “cut” at high cost edges to get desired number of clusters.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees"
    ]
  },
  {
    "objectID": "datastructs/hash.html",
    "href": "datastructs/hash.html",
    "title": "Hashing",
    "section": "",
    "text": "Hashing\nHashing is a technique used in data structures to store and retrieve data efficiently. It involves using a hash function to map data items to a fixed-size array which is called a hash table.\nHow it works:\n\nHash Function: You provide your data items into the hash function.\nHash Code: The hash function crunches the data and give a unique hash code.\nHash Table: The hash code then points you to a specific location within the hash table.\n\nA hash table is also known as a hash map. It is a data structure that stores key-value pairs. It uses a hash function to map keys to a fixed-size array, called a hash table. This allows in faster search, insertion, and deletion operations.\n\n\nHash Function\nThe hash function is a function that takes a key and returns an index into the hash table. The goal of a hash function is to distribute keys evenly across the hash table, minimizing collisions (when two keys map to the same index).\nCommon hash functions include:\n\nDivision Method: Key % Hash Table Size\nMultiplication Method: (Key * Constant) % Hash Table Size\nUniversal Hashing: A family of hash functions designed to minimize collisions\n\n\n\nHash Collision\nA hash collision occurs when two different keys map to the same index in a hash table. This can happen even with a good hash function, especially if the hash table is full or the keys are similar.\nCauses of Hash Collisions:\n\nPoor Hash Function: A hash function that does not distribute keys evenly across the hash table can lead to more collisions.\nHigh Load Factor: A high load factor (ratio of keys to hash table size) increases the probability of collisions.\nSimilar Keys: Keys that are similar in value or structure are more likely to collide.\n\n\n\nCollision Resolution Techniques\nThere are two types of collision resolution techniques:\n\nOpen Addressing:\n\nLinear Probing: Search for an empty slot sequentially\nQuadratic Probing: Search for an empty slot using a quadratic function\n\n\n\n\n\n\nClosed Addressing:\n\nChaining: Store colliding keys in a linked list or binary search tree at each index\nCuckoo Hashing: Use multiple hash functions to distribute keys\n\n\n\n\n\nHash tables are used in a wide variety of applications, including:\nDatabases: Storing and retrieving data based on unique keys Caching: Storing frequently accessed data for faster retrieval Symbol Tables: Mapping identifiers to their values in programming languages Network Routing: Determining the best path for data packets",
    "crumbs": [
      "Home",
      "HASHMAPS",
      "Hashing"
    ]
  },
  {
    "objectID": "datastructs/hashmaps.html",
    "href": "datastructs/hashmaps.html",
    "title": "HASHMAPS",
    "section": "",
    "text": "Hashing is a technique used in data structures to store and retrieve data efficiently. It involves using a hash function to map data items to a fixed-size array which is called a hash table. Hash tables are used in a wide variety of applications, including databases, caching systems, and symbol tables.\n\n\n\n\nHash sets are collections of distinct elements that are stored in a way that allows for quick access and retrieval. Sets are commonly used in computer science to store unique elements and perform set operations such as union, intersection, and difference.\nSets are collections of distinct elements that are stored in a way that allows for quick access and retrieval. Sets are commonly used in computer science to store unique elements and perform set operations such as union, intersection, and difference.\n\nTOC {:toc}\n\n\n\nHash Table (also known as a hash map) is a fundamental data structure that efficiently stores and retrieves data in a way that allows for quick access. It involves mapping data to a specific index in a hash table using a hash function that enables fast retrieval of information based on its key. This method is commonly used in databases, caching systems, and various programming applications to optimize search and retrieval operations.\n\n\n\n\nIn Python, hash tables are implemented using the dict data structure, which is a built-in data type that stores key-value pairs. Hash tables in Python are optimized for fast search, insert, and delete operations.\n# Create a hash table\nhash_table = {}\n\n# Insert a key-value pair\nhash_table[\"key1\"] = \"value1\"\n\n# Retrieve a value based on key\nvalue = hash_table[\"key1\"]\n\n# Check if a key is in the hash table\nif \"key1\" in hash_table:\n    print(\"Key found in hash table\")\n\n\n\nHash tables support a variety of operations, including:\n\nSearch: Retrieve the value associated with a key.\nInsert: Add a new key-value pair to the hash table.\nDelete: Remove a key-value pair from the hash table.\nUpdate: Change the value associated with a key.\nSize: Get the number of key-value pairs in the hash table.\n\n# Create a hash table\nhash_table = {}\n\n# Insert key-value pairs\nhash_table[\"key1\"] = \"value1\"\nhash_table[\"key2\"] = \"value2\"\nhash_table[\"key3\"] = \"value3\"\n\n# Search for a key\nvalue = hash_table.get(\"key2\")\n\n# Delete a key\ndel hash_table[\"key3\"]\n\n# Update a value\nhash_table[\"key1\"] = \"new_value\"\n\n# Get the size of the hash table\nsize = len(hash_table)\n\n\n\nThe time complexity of hash table operations depends on the efficiency of the hash function and the collision resolution technique. In general, hash table operations have an average-case time complexity of O(1) for search, insert, and delete operations.\nThe space complexity of a hash table is O(n), where n is the number of key-value pairs stored in the table. The space complexity can vary based on the load factor and the collision resolution technique used.",
    "crumbs": [
      "Home",
      "HASHMAPS"
    ]
  },
  {
    "objectID": "datastructs/hashmaps.html#hash-table",
    "href": "datastructs/hashmaps.html#hash-table",
    "title": "HASHMAPS",
    "section": "",
    "text": "Hash Table (also known as a hash map) is a fundamental data structure that efficiently stores and retrieves data in a way that allows for quick access. It involves mapping data to a specific index in a hash table using a hash function that enables fast retrieval of information based on its key. This method is commonly used in databases, caching systems, and various programming applications to optimize search and retrieval operations.\n\n\n\n\nIn Python, hash tables are implemented using the dict data structure, which is a built-in data type that stores key-value pairs. Hash tables in Python are optimized for fast search, insert, and delete operations.\n# Create a hash table\nhash_table = {}\n\n# Insert a key-value pair\nhash_table[\"key1\"] = \"value1\"\n\n# Retrieve a value based on key\nvalue = hash_table[\"key1\"]\n\n# Check if a key is in the hash table\nif \"key1\" in hash_table:\n    print(\"Key found in hash table\")\n\n\n\nHash tables support a variety of operations, including:\n\nSearch: Retrieve the value associated with a key.\nInsert: Add a new key-value pair to the hash table.\nDelete: Remove a key-value pair from the hash table.\nUpdate: Change the value associated with a key.\nSize: Get the number of key-value pairs in the hash table.\n\n# Create a hash table\nhash_table = {}\n\n# Insert key-value pairs\nhash_table[\"key1\"] = \"value1\"\nhash_table[\"key2\"] = \"value2\"\nhash_table[\"key3\"] = \"value3\"\n\n# Search for a key\nvalue = hash_table.get(\"key2\")\n\n# Delete a key\ndel hash_table[\"key3\"]\n\n# Update a value\nhash_table[\"key1\"] = \"new_value\"\n\n# Get the size of the hash table\nsize = len(hash_table)\n\n\n\nThe time complexity of hash table operations depends on the efficiency of the hash function and the collision resolution technique. In general, hash table operations have an average-case time complexity of O(1) for search, insert, and delete operations.\nThe space complexity of a hash table is O(n), where n is the number of key-value pairs stored in the table. The space complexity can vary based on the load factor and the collision resolution technique used.",
    "crumbs": [
      "Home",
      "HASHMAPS"
    ]
  },
  {
    "objectID": "datastructs/trees.html",
    "href": "datastructs/trees.html",
    "title": "TREES",
    "section": "",
    "text": "Trees are one of the most important data structures in computer science. They are a non-linear data structure that store data in a hierarchical manner.\nTrees offer efficient insertion, deletion, and search operations, making them a versatile data structure for a wide range of applications.\nTrees are ubiquitous in computer science and are used for a wide variety of applications, including file systems, parsing languages, and artificial intelligence to plan out strategies and make decisions.",
    "crumbs": [
      "Home",
      "TREES"
    ]
  },
  {
    "objectID": "datastructs/trees.html#terminology",
    "href": "datastructs/trees.html#terminology",
    "title": "TREES",
    "section": "Terminology",
    "text": "Terminology\nThe tree data structure come with a non-trivial amount of terminology. Here are some of the key terms:\n\nNodes: The individual elements in a tree that store data. These are depicted as circles in the diagram. They are very similar to linked list nodes.\nEdges: The connections between nodes. These are depicted as lines in the diagram.\nRoot Node: The topmost node in a tree. It is the only node in the tree that has no parent.\n\n\n\n\n\n\nParent Node: A node that has child nodes. Each node in the tree, except the root node, has exactly one parent node.\nChild Node: A node that is connected to a parent node. Each node in the tree can have zero or more children.\nLeaf: Nodes that have no child nodes. They are the nodes at the bottom of the tree.\nPath: A sequence of nodes connected by edges.\nHeight of a tree: The length of the longest path from the root to a leaf. Length is measured in the number of edges.\nHeight of a node: The length of the longest path from the node to a leaf. Length is measured in the number of edges.\nDepth: The length of the path from the root to a node. Length is measured in the number of edges.\nLevel: The depth of a node in the tree. The root node is at level 0.\nSubtree: A tree that is part of a larger tree. It consists of a node and all its descendants.\nInternal Node: A node that has at least one child node. Essentially, any node that is not a leaf.\nExternal Node: A node that has no child nodes. Essentially, a leaf node.\nSibling: Nodes that share the same parent.\nAncestors of a node: A node that is on the upward path a given node to the root.\nDescendant of a node: A node that is on the path from a given node to a leaf.",
    "crumbs": [
      "Home",
      "TREES"
    ]
  },
  {
    "objectID": "datastructs/trees.html#types-of-trees",
    "href": "datastructs/trees.html#types-of-trees",
    "title": "TREES",
    "section": "Types of Trees",
    "text": "Types of Trees\nThere are many different types of trees, each with its own unique properties and characteristics. Here we are focusing on types of trees based on the number of children each node can have.\nNote that we are going the following mathematical notation for trees:\n\n\\(n\\) to represent the number of nodes in the tree,\n\\(N\\) to represent the maximum number of children each node can have\n\\(h\\) to represent the height of the tree.\n\n\n\n\n\nThe most common types of trees Binary trees that have at most two children per node. Binary trees are further classified into different types based on their properties.\n\n\n\n\nFull Tree\nAn \\(N\\)-ary tree in which every node has either zero or \\(N\\) children.\nComplete Tree\nAn \\(N\\)-ary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nDegenerate Tree\nA tree in which each parent node has only one child node. This is essentially a linked list.\nPerfect Tree\nAn \\(N\\)-ary tree in which all interior nodes have \\(N\\) children and all leaves have the same depth or same level.\nBalanced Tree\nA \\(N\\)-ary tree in which the heights of all the subtrees of each node differ by at most one.",
    "crumbs": [
      "Home",
      "TREES"
    ]
  },
  {
    "objectID": "datastructs/trees.html#properties-of-trees",
    "href": "datastructs/trees.html#properties-of-trees",
    "title": "TREES",
    "section": "Properties of Trees",
    "text": "Properties of Trees\nTrees have the following properties:\n\nTree Property: A tree with \\(n\\) nodes has \\(n-1\\) edges.\nThe number of edges in a tree is always one less than the number of nodes.\nThis is because each node, except the root node, has exactly one parent node.\nFull Tree Property: An N-ary tree with height \\(h\\) has at most \\(N^h\\) nodes.\nA full tree is a tree in which each node has exactly \\(N\\) children.\nHeight Property: The height of an N-ary tree with \\(n\\) nodes is \\(\\log_N(n+1) - 1\\).\nThe height of a tree is the length of the longest path from the root to a leaf.",
    "crumbs": [
      "Home",
      "TREES"
    ]
  },
  {
    "objectID": "datastructs/graphs_prim.html",
    "href": "datastructs/graphs_prim.html",
    "title": "Prim-Jarník Algorithm",
    "section": "",
    "text": "Prim’s algorithm is a greedy algorithm that finds a minimum spanning tree for a connected, undirected graph.\nThe algorithm builds the MST by:\nThe main idea is similar to that of Dijkstra’s algorithm.\nIn the Prim-Jarník algorithm, we grow a minimum spanning tree from a single cluster starting from some “root” vertex s.\nWe will begin with some vertex \\(s\\), defining the initial “cloud” of vertices \\(C\\).\nThen, in each iteration, we choose a minimum-weight edge \\(e = (u, v)\\), connecting \\(a\\) vertex \\(u\\) in the cloud \\(C\\) to a vertex \\(v\\) outside of \\(C\\).\nThe vertex v is then brought into the cloud C and the process is repeated until a spanning tree is formed. Again, the crucial fact about minimum spanning trees comes into play, for by always choosing the smallest-weight edge joining a vertex inside C to one outside C, we are assured of always adding a valid edge to the MST.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees",
      "Prim-Jarník Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graphs_prim.html#analysis",
    "href": "datastructs/graphs_prim.html#analysis",
    "title": "Prim-Jarník Algorithm",
    "section": "Analysis",
    "text": "Analysis\nThe time complexity of Prim’s algorithm is \\(O(V^2)\\) with an adjacency matrix representation and \\(O(E log V)\\) with an adjacency list representation, where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph.\nThe implementation issues for the Prim-Jarník algorithm are similar to those for Dijkstra’s algorithm, relying on an adaptable priority queue \\(Q\\). We initially perform \\(n\\) insertions into \\(Q\\), later perform \\(n\\) extract-min operations, and may update a total of \\(m\\) priorities as part of the algorithm.\nThose steps are the primary contributions to the overall running time.\nWith a heap-based priority queue, each operation runs in \\(O(log n)\\) time, and the overall time for the algorithm is \\(O((n+m)logn)\\), which is \\(O(mlogn)\\) for a connected graph.\nAlternatively, we can achieve \\(O(n^2)\\) running time by using an unsorted list as a priority queue.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Minimum Spanning Trees",
      "Prim-Jarník Algorithm"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html",
    "href": "datastructs/graph_traversals.html",
    "title": "Traversals",
    "section": "",
    "text": "Breadth-first search (BFS) is a graph traversal algorithm that explores all vertices at the current depth before moving to the vertices at the next depth.\nBFS for a graph is similar to BFS for a tree. The main difference is that:\n\nnodes in a graph can have multiple parents, whereas nodes in a tree have only one parent. So, we need to keep track of the parent of each node to reconstruct the path from the starting node to the target node.\ntrees are acyclic, so we do not need to keep track of visited vertices, whereas graphs can contain cycles, so we may visit the same vertex again. To avoid processing a vertex more than once, we use a boolean array to mark the visited vertices.\n\n\n\n\n\nThe steps of BFS are as follows:\n\nInitialize a queue to store vertices to visit and a set to store visited vertices.\nEnqueue the starting vertex into the queue and mark it as visited.\nWhile the queue is not empty:\n\nDequeue a vertex from the queue.\nFor each neighbor of the dequeued vertex that has not been visited:\n\nEnqueue the neighbor into the queue and mark it as visited.\nRecord the parent of the neighbor (the vertex from which it was reached).\n\n\nOnce the target vertex is reached, reconstruct the path from the starting vertex to the target vertex using the recorded parents.\n\n\n      \n\nThe time complexity of BFS is O(V + E), where V is the number of vertices and E is the number of edges in the graph.\nSimilar to BFS for a tree, BFS for a graph uses a Queue internally to keep track of the vertices to visit next.\nThe additional data structure used in BFS for a graph is a boolean array to keep track of visited vertices.\n\n\n\n\nThe time complexity of BFS for a graph is \\(O(V + E)\\), where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph.\nThe space complexity of BFS for a graph is \\(O(V)\\), where \\(V\\) is the number of vertices in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html#breadth-first-search-bfs",
    "href": "datastructs/graph_traversals.html#breadth-first-search-bfs",
    "title": "Traversals",
    "section": "",
    "text": "Breadth-first search (BFS) is a graph traversal algorithm that explores all vertices at the current depth before moving to the vertices at the next depth.\nBFS for a graph is similar to BFS for a tree. The main difference is that:\n\nnodes in a graph can have multiple parents, whereas nodes in a tree have only one parent. So, we need to keep track of the parent of each node to reconstruct the path from the starting node to the target node.\ntrees are acyclic, so we do not need to keep track of visited vertices, whereas graphs can contain cycles, so we may visit the same vertex again. To avoid processing a vertex more than once, we use a boolean array to mark the visited vertices.\n\n\n\n\n\nThe steps of BFS are as follows:\n\nInitialize a queue to store vertices to visit and a set to store visited vertices.\nEnqueue the starting vertex into the queue and mark it as visited.\nWhile the queue is not empty:\n\nDequeue a vertex from the queue.\nFor each neighbor of the dequeued vertex that has not been visited:\n\nEnqueue the neighbor into the queue and mark it as visited.\nRecord the parent of the neighbor (the vertex from which it was reached).\n\n\nOnce the target vertex is reached, reconstruct the path from the starting vertex to the target vertex using the recorded parents.\n\n\n      \n\nThe time complexity of BFS is O(V + E), where V is the number of vertices and E is the number of edges in the graph.\nSimilar to BFS for a tree, BFS for a graph uses a Queue internally to keep track of the vertices to visit next.\nThe additional data structure used in BFS for a graph is a boolean array to keep track of visited vertices.\n\n\n\n\nThe time complexity of BFS for a graph is \\(O(V + E)\\), where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph.\nThe space complexity of BFS for a graph is \\(O(V)\\), where \\(V\\) is the number of vertices in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html#depth-first-search-dfs",
    "href": "datastructs/graph_traversals.html#depth-first-search-dfs",
    "title": "Traversals",
    "section": "Depth-First Search (DFS)",
    "text": "Depth-First Search (DFS)\nDFS is an algorithm that explores as far as possible along each branch before backtracking.\n\n\n\n\nIt uses a stack to keep track of the vertices to visit next. The pseudocode for DFS is as follows:\n\nStart at a vertex \\(v\\) and mark it as visited.\nRecursively visit all adjacent vertices of \\(v\\) that have not been visited.\nRepeat step 2 for each unvisited adjacent vertex.\n\nThe time complexity of DFS for a graph is \\(O(V + E)\\), where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html#applications-of-graph-traversals",
    "href": "datastructs/graph_traversals.html#applications-of-graph-traversals",
    "title": "Traversals",
    "section": "Applications of Graph Traversals",
    "text": "Applications of Graph Traversals\nGraph traversals are fundamental algorithms in graph theory and have many applications, including:\n\nPathfinding algorithms like Dijkstra’s algorithm and A* search algorithm.\nNetwork analysis and routing algorithms.\nTopological sorting algorithms.\nDetecting cycles in a graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html#finding-cycle-in-a-graph",
    "href": "datastructs/graph_traversals.html#finding-cycle-in-a-graph",
    "title": "Traversals",
    "section": "Finding Cycle in a Graph",
    "text": "Finding Cycle in a Graph\nA cycle in a graph is a path that starts and ends at the same vertex. Detecting cycles in a graph is an important problem in graph theory and has many applications, such as deadlock detection in operating systems, cycle detection in resource allocation, and detecting negative cycles in financial transactions.\n\n\n\n\nTo detect cycles in a graph, we can use the Depth-First Search (DFS) algorithm. The idea is to maintain a boolean array visited to keep track of the vertices visited during the DFS traversal. If we encounter a vertex that is already visited and is not the parent of the current vertex, then there is a cycle in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_traversals.html#finding-connected-components-in-a-graph",
    "href": "datastructs/graph_traversals.html#finding-connected-components-in-a-graph",
    "title": "Traversals",
    "section": "Finding Connected Components in a Graph",
    "text": "Finding Connected Components in a Graph\nConnected components in a graph are subgraphs in which every pair of vertices is connected by a path. To find connected components in a graph, we can use either Depth-First Search (DFS) or Breadth-First Search (BFS).\n\n\n\nThe idea is to start a traversal from each unvisited vertex and mark all the vertices reachable from that vertex. The number of times we start a traversal is the number of connected components in the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Traversals"
    ]
  },
  {
    "objectID": "datastructs/graph_implementations.html",
    "href": "datastructs/graph_implementations.html",
    "title": "Implementations",
    "section": "",
    "text": "There are several ways to implement a graph, each with its own advantages and disadvantages. The choice of implementation depends on the specific requirements of the application, such as the number of vertices and edges, the operations to be performed on the graph, and the memory constraints.\nFour common ways to represent a graph are:\n\n\n\n\n\n\n\n\nRepresentation\nDescription\nSpace Complexity\n\n\n\n\n1. Adjacency Matrix\nA 2D array of size \\(V \\times V\\) where \\(V\\) is the number of vertices in the graph.\n\\(O(V^2)\\)\n\n\n2. Adjacency List\nAn array of lists where each list represents the neighbors of a vertex.\n\\(O(V + E)\\)\n\n\n3. Edge List\nA list of all the edges in the graph.\n\\(O(E)\\)\n\n\n4. Incidence Matrix\nA 2D array of size \\(V \\times E\\) where \\(V\\) is the number of vertices and \\(E\\) is the number of edges.\n\\(O(V \\times E)\\)\n\n\n\n\n\nAn adjacency matrix is a 2D array of size \\(V \\times V\\), where \\(V\\) is the number of vertices in the graph. If the value of the matrix element at row \\(i\\) and column \\(j\\) is 1, it indicates an edge between vertices \\(i\\) and \\(j\\). For weighted graphs, the matrix can store the weight of the edge instead of 1.\n\n\n\nThere are two types of adjacency matrices:\n\nUnweighted Graphs: The matrix elements are 0 or 1, indicating the absence or presence of an edge.\nWeighted Graphs: The matrix elements are the weights of the edges.\n\nSimilarly, for directed graphs, the adjacency matrix can be asymmetric, with different values for the in-degree and out-degree.\nAdjacency matrices are useful for dense graphs, where the number of edges is close to the maximum possible number of edges.\n\n\n\nAn adjacency list is a collection of lists or arrays used to represent the graph. Each vertex has a list of adjacent vertices. This representation is more space-efficient than an adjacency matrix for sparse graphs.\n\n\n\n\nIn an adjacency list:\n\nFor an undirected graph, each edge \\((u, v)\\) is stored twice: once in the list of \\(u\\) and once in the list of \\(v\\).\nFor a directed graph, the edge \\((u, v)\\) is stored only in the list of \\(u\\).\n\nAdjacency lists are useful for sparse graphs, where the number of edges is much less than the maximum possible number of edges.\n\n\n\nAn edge list is a list of all the edges in the graph. Each edge is represented as a tuple \\((u, v)\\), where \\(u\\) and \\(v\\) are the vertices connected by the edge. For weighted graphs, the tuple can include the weight of the edge.\n\n\n\nEdge lists are useful for algorithms that require iterating over all the edges of the graph.\n\n\n\nAn incidence matrix is a 2D array of size \\(V \\times E\\), where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph. Each row represents a vertex, and each column represents an edge. The matrix elements indicate the incidence of a vertex in an edge.\n\n\n\nIncidence matrices are useful for bipartite graphs and network flow problems.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Implementations"
    ]
  },
  {
    "objectID": "datastructs/graph_implementations.html#adjacency-matrix",
    "href": "datastructs/graph_implementations.html#adjacency-matrix",
    "title": "Implementations",
    "section": "",
    "text": "An adjacency matrix is a 2D array of size \\(V \\times V\\), where \\(V\\) is the number of vertices in the graph. If the value of the matrix element at row \\(i\\) and column \\(j\\) is 1, it indicates an edge between vertices \\(i\\) and \\(j\\). For weighted graphs, the matrix can store the weight of the edge instead of 1.\n\n\n\nThere are two types of adjacency matrices:\n\nUnweighted Graphs: The matrix elements are 0 or 1, indicating the absence or presence of an edge.\nWeighted Graphs: The matrix elements are the weights of the edges.\n\nSimilarly, for directed graphs, the adjacency matrix can be asymmetric, with different values for the in-degree and out-degree.\nAdjacency matrices are useful for dense graphs, where the number of edges is close to the maximum possible number of edges.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Implementations"
    ]
  },
  {
    "objectID": "datastructs/graph_implementations.html#adjacency-list",
    "href": "datastructs/graph_implementations.html#adjacency-list",
    "title": "Implementations",
    "section": "",
    "text": "An adjacency list is a collection of lists or arrays used to represent the graph. Each vertex has a list of adjacent vertices. This representation is more space-efficient than an adjacency matrix for sparse graphs.\n\n\n\n\nIn an adjacency list:\n\nFor an undirected graph, each edge \\((u, v)\\) is stored twice: once in the list of \\(u\\) and once in the list of \\(v\\).\nFor a directed graph, the edge \\((u, v)\\) is stored only in the list of \\(u\\).\n\nAdjacency lists are useful for sparse graphs, where the number of edges is much less than the maximum possible number of edges.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Implementations"
    ]
  },
  {
    "objectID": "datastructs/graph_implementations.html#edge-list",
    "href": "datastructs/graph_implementations.html#edge-list",
    "title": "Implementations",
    "section": "",
    "text": "An edge list is a list of all the edges in the graph. Each edge is represented as a tuple \\((u, v)\\), where \\(u\\) and \\(v\\) are the vertices connected by the edge. For weighted graphs, the tuple can include the weight of the edge.\n\n\n\nEdge lists are useful for algorithms that require iterating over all the edges of the graph.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Implementations"
    ]
  },
  {
    "objectID": "datastructs/graph_implementations.html#incidence-matrix",
    "href": "datastructs/graph_implementations.html#incidence-matrix",
    "title": "Implementations",
    "section": "",
    "text": "An incidence matrix is a 2D array of size \\(V \\times E\\), where \\(V\\) is the number of vertices and \\(E\\) is the number of edges in the graph. Each row represents a vertex, and each column represents an edge. The matrix elements indicate the incidence of a vertex in an edge.\n\n\n\nIncidence matrices are useful for bipartite graphs and network flow problems.",
    "crumbs": [
      "Home",
      "GRAPHS",
      "Implementations"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Syed Fahad Sultan سید فہد سلطان \nPronunciation: Saiyyudh Fahad Sool-tahn\nJust call me “Dr. Sultan” (click on the speaker for a short audio clip: 🔈)\n\n\n\n\n\nI am originally from Lahore, Pakistan and joined Furman University in Fall 2022 after earning my Ph.D. in Computer Science from State University of New York at Stony Brook.\n\n\n\n\n\nFresh out of college, I worked as a professional video game developer for a startup that later got acquired by the Japanese gaming giant DeNA. During this time, I was part of the team that built TapFish, the top-grossing game worldwide, for two weeks in 2011, on both the App Store and Google Play.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVideo games development\n\n\n\nUrban Sensing\n\n\n\nComputational Neuroscience\n\n\n\n\n\n\n\n\nI then went on to work at Technology for People Initiative, an applied research lab in my where I mined social media and cell phone data for proxies of socio-economic indicators that allowed more inclusive policy-making for marginalized communities. During these years, I also dabbled in data journalism and helped organize a boot camp on using data for journalists with the support of the International Center for Journalists (ICFJ) and the Knight Foundation.\n\nIn 2015, I moved to Mecca, Saudi Arabia to work for the GIS Innovation Center (now Wadi Makkah). There I worked on innovative urban sensing techniques for better crowd control during the annual pilgrimage to the city, the largest human gathering in the world every year.\nDuring my PhD, I worked at the intersection of computational neuroscience, bioinformatics and machine learning. My work focused on identifying neurological and genetic biomarkers linking type-2 diabetes with cognitive disorders such as Alzheimer’s and other dementias.\nI live in Travelers Rest with my wife and cat.\n\n\nOffice: Riley Hall 200-H\nEmail: fahad.sultan@furman.edu\nI have an Open door policy. I am in my office during work hours most weekdays and my door is only closed if I am in a class or in a meeting. So please drop by.\nYou can also schedule a meeting using this link if you want to absolutely make sure that I am available.\n\n\n\n\n\n\nCourse website: https://fahadsultan.com/csc223\nThe Syllabus is available on the course website. In particular, please make sure to read the Grading, Academic Integrity and Textbook and other Resources sections carefully.\nAll of the course content will be posted on this website.\nImportant announcements will be made on both the course website homepage and in class.\nYou are to submit assignments and exams on the course Moodle page. I will also upload all of your grades there.\n\n\n\nDeclarative knowledge is knowledge about facts. It is knowledge that answers the “What is” questions. Most courses outside Computer Science are about declarative knowledge.\nIn contrast, Imperative knowledge is knowledge about how to do things. It is knowledge that answers the “How to” questions.\nWhile we will spend a non-trivial amount of time in this course on declarative knowledge, the overwhelming majority of this course will focus on imperative knowledge. Your grade in this course will be determined by your ability to apply declarative and more importantly imperative knowledge to solve problems.\n\nResearch shows that there is only one way to acquire imperative knowledge: Practice, Practice, Practice !. Practice combined with feedback is the only way to achieve mastery.\nIn this course, you will be given ample opportunities to practice along with regular feedback.\n\n\n\nApproach assignments purely as opportunities to learn, prepare for exams and to prepare for your career.\n\nIt is not worth cheating on assignments. Just come talk to me if you are struggling with an assignment. I will literally just tell you the answer.\nOn assignments, expect near maximal flexibility from me. Every assignment will be due 10 days calendar after it is posted.\nYou can schedule a time to get your assignments graded using this link.\nWritten Assignments:\nWritten assignments are to help you build a deeper understanding of algorithms and math covered in class.\nThese could simply be math problems or involve tracing algorithms and dry-runs.\nBoth handwritten or typed submissions are acceptable. Submissions, as always, on Moodle.\nProgramming Assignments:\nProgramming assignments are going to be posted at the start of the lab session each week and will be due in 10 days, unless otherwise specified.\nAll Programming assignments will be graded through an in-person code review. You are to give a walkthrough of your code and be able to answer questions about it.\nDuring these code review, you will be given feedback on how to improve your code and avoid common mistakes.\nYou should expect questions in the exams similar to assignments.\n\n\n\nI have created 10 graded items under class participation on Moodle. In class, you will be asked to answer a question or solve a problem. You will be graded on the basis of your participation. It is your responsibility to make sure you have 10 points by the end of the semester.\nThere are 10 graded items under class participation on Moodle. In class, you will be asked to answer a question or solve a problem. You will be graded on the basis of your participation. It is your responsibility to make sure you have 10 points by the end of the semester.\n\\[\\frac{24~\\text{students} \\times 10~\\text{points needed by each student}}{15~\\text{weeks} \\times 2~\\text{classes per week}} = 8~\\text{points given out class, on average}\\]\nI will give out class participation points in every class class for answering or asking a question.\nGiven the glut of information accessible online and otherwise in this day and age, meaningful interactions with your peers and teachers is essentially why you are paying your college tuition.\nPlease come to class, labs and office hours\nPlease ask questions during class\nPlease answer questions and participate in discussions during class\n\n\n\nThere will be three exams in the course, including the final. The final exam will be cumulative. Exams constitute 60% of your course grade.\nAll exams will be on computer, with a large programming component. Questions will be posted on Moodle and you will have to submit your solutions on Moodle, just like assignments.\nYou will be evaluated on your ability to apply knowledge to new problems and not just on your ability to retain and recall information.\nThe exams, more than the assignments, are going to determine your grade.\nAll exams are going to be cumulative, with focus on the topics covered since last exam.\nDiligent work on the homework and assignments will be rewarded here.\n\n\n\nEverything is tentative and subject to change\n\nThis is my first teaching this course. Any and all feedback is welcome!\nI have created an anonymous feedback poll on Moodle. Please use this to anonymously share any feedback.\nShare any changes you want me to make in the course, at any point in the semester. You can submit multiple times over the span of the semester.\nThink of it as a Complaints Box for the course.\n\n\n\n\nThe course is called Data Structures & Algorithms. In my opinion, a more appropriate name for the course would have been Complexities, Abstractions and Scalability.\nComplexity is the primary challenge we will be dealing with in this course. Abstractions are going to be our primary tool to deal with complexity. Scalability is the primary goal in this course i.e. to write code that can handle the data we have today and the data we expect to have in the future.\n\nIn the world of software development, lines of code (LOC) are often used as a metric to measure the size and complexity of a codebase. The more lines of code a project has, the larger and more intricate it is likely to be.\nHow many millions of lines of code does it take to make the modern program, web service, car, or airplane possible? The figure below sheds some light on this question.\n\n\n\nThe range is extraordinary: the average iPhone app has less than 50,000 lines of code, while Google’s entire code base is two billion lines for all services. The code needed for fighter jets, popular video game engines, and even the Large Hadron Collider falls somewhere in between the two. It’s been said that the modern smartphone has more lines of code than a passenger jet – and that the code for a typical car has 100 million lines of code.\nIn fact, the lines of code for the Apollo 11 moon lander totaled just 145,000 – and the code for the Space Shuttle was about the same.\nIt’s more than what was needed to run old technologies like the Space Shuttle, a pacemaker, or even the game engine of Quake 3 – but it’s not enough to be the driving force behind the modern software that’s used in everyday life today.\n\nA million lines of code, if printed, would be about 18,000 pages of text. That’s 14x the length of War and Peace.\nHow do we then manage this complexity? A large part of the answer lies in Abstractions. Abstractions are ways of dividing a complex system into smaller, more manageable pieces. Each piece is a black box or module that can be used without having to know how it works internally. However, the pieces are not completely opaque. They have a well-defined interface that allows us to use them without knowing how they work internally.\nOn the other hand, the amount of Data that we have to deal with is growing exponentially. Approximately 328.77 million terabytes of data are created each day.\n\nHere’s a selection of other user-generated internet content stats:\n\n\n\nType of Media\nAmount per Minute\nAmount per Day\n\n\n\n\nEmails sent\n231.4 million\n333.22 billion\n\n\nTexts sent\n16 million\n24.04 billion\n\n\nGoogle searches\n5.9 million\n8.5 billion\n\n\nSnaps shared on Snapchat\n2.43 million\n3.5 billion\n\n\nPieces of content shared on Facebook\n1.7 million\n2.45 billion\n\n\nSwipes on Tinder\n1.1 million\n1.58 billion\n\n\nHours streamed\n1 million\n1.44 billion\n\n\nUSD spent on Amazon\n443,000\n637.92 million\n\n\nUSD sent on Venmo\n437,600\n630.14 million\n\n\nTweets shared on Twitter\n347,200\n499.97 million\n\n\nHours spent in Zoom meetings\n104,600\n150.62 million\n\n\nUSD spent on DoorDash\n76,400\n110.02 million\n\n\n\nFor the software engineer this means writing code that can not only handle the data we have today, but also data that we expect to have in the future. In other words, we need to write code that is scalable.\n\n\n\nA LOT of problems in computer science can be ‘reduced’ to a very small set of fundamental problems.\nIn this course, we are going to focus on the six of such fundamental problems.\n\nSearch : Given a set of data, find a particular element in the set\nSort : Given a set of data, arrange the elements in a particular order\n\n3-6. Create, Read, Update, Delete (CRUD)\n\n\nWe are concerned with the process of collecting information in a computer’s memory, in such a way that the information can subsequently be recovered as quickly as possible.\n\nIn this course, we are going to focus on the simplest form of search: searching for a single element in a set of data i.e.  how to find the data that has been stored with a given identification. For example, in a numerical application we might want to find \\(f(x)\\), given \\(x\\) and a table of the values of \\(f\\); in a nonnumerical application, we might want to find the English translation of a given Russian word.\nIn general, we shall suppose that a set of \\(N\\) records has been stored, and the problem is to locate the appropriate one. As in the case of sorting, we assume that each record includes a special field called its key; this terminology is especially appropriate, because many people spend a great deal of time every day searching for their keys. We generally require the \\(N\\) keys to be distinct, so that each key uniquely identifies its record. Algorithms for searching are presented with a so-called argument, \\(q\\), and the problem is to find which record has \\(q\\) as its key.\nAfter the search is complete, two possibilities can arise:\n\nEither the search was successful, having located the unique record containing \\(q\\); or\nIt was unsuccessful, having determined that \\(q\\) is nowhere to be found.\n\nFormally, the search problem is defined as follows:\n\nProblem: \\(\\textbf{Search}\\)\nInput: A set of \\(n\\) keys \\(S\\), and a query key \\(q\\).\nRequired Output: The location of \\(q\\) in \\(S\\), if present, else \\(-1\\).\n\nSearching is the most time-consuming part of many programs, and the substitution of a good search method for a bad one often leads to a substantial increase in speed. In fact we can often arrange the data or the data structure so that searching is eliminated entirely, by ensuring that we always know just where to find the information we need.\nEfficient algorithms for searching turn out to be quite important in practice.\n\n\n\nTypical computer science students study the basic sorting algorithms at least three times before they graduate: first in introductory programming, then in data structures, and finally in an advanced algorithms course.\n\nWhy is sorting worth so much attention? There are several reasons:\n\nSorting is the basic building block that many other algorithms are built around. By understanding sorting, we obtain an amazing amount of power to solve other problems.\nMost of the interesting ideas used in the design of algorithms appear in the context of sorting, such as divide-and-conquer, data structures, and randomized algorithms.\nComputers have historically spent more time sorting than doing anything else. Research shows that a quarter of all computer cycles were spent sorting data [Knu98]. Sorting remains the most ubiquitous combinatorial algorithm problem in practice.\nSorting is the most thoroughly studied problem in computer science. Literally dozens of different algorithms are known, most of which possess some particular advantage over all other algorithms in certain situations.\n\nFormally, the sorting problem is defined as follows:\n\nProblem: \\(\\textbf{Sorting}\\)\nInput: A sequence of \\(n\\) numbers \\(a_1, a_2, \\dots, a_n\\).\nRequired Output: A permutation (reordering) \\(a_1', a_2', \\dots, a_n'\\) of the input sequence such that \\(a_1' \\leq a_2' \\leq \\dots \\leq a_n'\\).\n\nIn this course, we will discuss sorting in reasonable detail, stressing how sorting can be applied to solving other problems. We will also also sorting as a way to introduce paradigms of algorithm design and analysis.\n\n\n\nCreate: Adding a record to a database, inserting a node into a linked list, and inserting an element into a priority queue are all examples of the insert problem. Other names of this problem include: Insert, Add, Post\n\nRead: Reading or accessing data is the most fundamental problem in computer science. Other names of this problem include: Access, Get, Fetch, Retrieve\nUpdate: For each of the following problems, we are given a set of N records, each record containing a key and some associated data, and we are given a particular key K. The problem is to modify the record containing K in some way. Other names of this problem include: Modify, Edit, Patch\nDelete: Deleting a record from a database, deleting a node from a linked list, and deleting an element from a priority queue are all examples of the delete problem. Other names of this problem include: Remove, Drop\n\n\n\n\n\nIn this course, we will also study non-linear data structures.\nNon-linear data structures are those in which each data element can connect to more than two other data elements.\nExamples of non-linear data structures include trees and graphs.\nTrees are a special type of graph, and have a hierarchical structure. Trees are used to represent the hierarchical relationships between data elements.\nExamples of applications of trees in computer science include the representation of file systems and the structure of many data formats such as JSON, XML and HTML.\n\n   \n\nGraphs are used to represent relationships between data elements that are not hierarchical.\nExamples of applications of graphs in computer science include the representation of social networks, the representation of the internet, and the representation of the structure of a computer network.\n\n\n\n\n\n\n\nThe P vs. NP problem is one of the seven Millennium Prize Problems. It asks whether every problem whose solution can be quickly verified by a computer can also be quickly solved by a computer.\n\n\n\nThe P vs. NP problem is one of the most important unsolved problems in computer science. It is also one of the most famous problems in computer science.\nThe P vs. NP problem is important because it has many practical implications. If P = NP, then many problems that are currently thought to be hard would become easy. For example, many problems in cryptography would become easy to solve.\n\n\n\nThe P problems are the problems that can be solved in polynomial time.\nThe NP problems are the problems that can be verified in polynomial time but as of yet, cannot be solved in polynomial time.\n\n\nThe traveling salesman problem is a problem in combinatorial optimization. It asks for the shortest possible route that visits each city exactly once and returns to the starting city.\n\n\n\nThe traveling salesman problem is one of the most important problems in computer science. It is used in many applications, such as vehicle routing, logistics, and manufacturing.\nOther famous NP-complete problems include the Traveling Salesman Problem, the Knapsack Problem, and the Graph Coloring Problem.",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#about-the-course",
    "href": "intro.html#about-the-course",
    "title": "Introduction",
    "section": "",
    "text": "Course website: https://fahadsultan.com/csc223\nThe Syllabus is available on the course website. In particular, please make sure to read the Grading, Academic Integrity and Textbook and other Resources sections carefully.\nAll of the course content will be posted on this website.\nImportant announcements will be made on both the course website homepage and in class.\nYou are to submit assignments and exams on the course Moodle page. I will also upload all of your grades there.\n\n\n\nDeclarative knowledge is knowledge about facts. It is knowledge that answers the “What is” questions. Most courses outside Computer Science are about declarative knowledge.\nIn contrast, Imperative knowledge is knowledge about how to do things. It is knowledge that answers the “How to” questions.\nWhile we will spend a non-trivial amount of time in this course on declarative knowledge, the overwhelming majority of this course will focus on imperative knowledge. Your grade in this course will be determined by your ability to apply declarative and more importantly imperative knowledge to solve problems.\n\nResearch shows that there is only one way to acquire imperative knowledge: Practice, Practice, Practice !. Practice combined with feedback is the only way to achieve mastery.\nIn this course, you will be given ample opportunities to practice along with regular feedback.\n\n\n\nApproach assignments purely as opportunities to learn, prepare for exams and to prepare for your career.\n\nIt is not worth cheating on assignments. Just come talk to me if you are struggling with an assignment. I will literally just tell you the answer.\nOn assignments, expect near maximal flexibility from me. Every assignment will be due 10 days calendar after it is posted.\nYou can schedule a time to get your assignments graded using this link.\nWritten Assignments:\nWritten assignments are to help you build a deeper understanding of algorithms and math covered in class.\nThese could simply be math problems or involve tracing algorithms and dry-runs.\nBoth handwritten or typed submissions are acceptable. Submissions, as always, on Moodle.\nProgramming Assignments:\nProgramming assignments are going to be posted at the start of the lab session each week and will be due in 10 days, unless otherwise specified.\nAll Programming assignments will be graded through an in-person code review. You are to give a walkthrough of your code and be able to answer questions about it.\nDuring these code review, you will be given feedback on how to improve your code and avoid common mistakes.\nYou should expect questions in the exams similar to assignments.\n\n\n\nI have created 10 graded items under class participation on Moodle. In class, you will be asked to answer a question or solve a problem. You will be graded on the basis of your participation. It is your responsibility to make sure you have 10 points by the end of the semester.\nThere are 10 graded items under class participation on Moodle. In class, you will be asked to answer a question or solve a problem. You will be graded on the basis of your participation. It is your responsibility to make sure you have 10 points by the end of the semester.\n\\[\\frac{24~\\text{students} \\times 10~\\text{points needed by each student}}{15~\\text{weeks} \\times 2~\\text{classes per week}} = 8~\\text{points given out class, on average}\\]\nI will give out class participation points in every class class for answering or asking a question.\nGiven the glut of information accessible online and otherwise in this day and age, meaningful interactions with your peers and teachers is essentially why you are paying your college tuition.\nPlease come to class, labs and office hours\nPlease ask questions during class\nPlease answer questions and participate in discussions during class\n\n\n\nThere will be three exams in the course, including the final. The final exam will be cumulative. Exams constitute 60% of your course grade.\nAll exams will be on computer, with a large programming component. Questions will be posted on Moodle and you will have to submit your solutions on Moodle, just like assignments.\nYou will be evaluated on your ability to apply knowledge to new problems and not just on your ability to retain and recall information.\nThe exams, more than the assignments, are going to determine your grade.\nAll exams are going to be cumulative, with focus on the topics covered since last exam.\nDiligent work on the homework and assignments will be rewarded here.\n\n\n\nEverything is tentative and subject to change\n\nThis is my first teaching this course. Any and all feedback is welcome!\nI have created an anonymous feedback poll on Moodle. Please use this to anonymously share any feedback.\nShare any changes you want me to make in the course, at any point in the semester. You can submit multiple times over the span of the semester.\nThink of it as a Complaints Box for the course.",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#data-structures-algorithms-complexity-abstraction-and-scalability",
    "href": "intro.html#data-structures-algorithms-complexity-abstraction-and-scalability",
    "title": "Introduction",
    "section": "",
    "text": "The course is called Data Structures & Algorithms. In my opinion, a more appropriate name for the course would have been Complexities, Abstractions and Scalability.\nComplexity is the primary challenge we will be dealing with in this course. Abstractions are going to be our primary tool to deal with complexity. Scalability is the primary goal in this course i.e. to write code that can handle the data we have today and the data we expect to have in the future.\n\nIn the world of software development, lines of code (LOC) are often used as a metric to measure the size and complexity of a codebase. The more lines of code a project has, the larger and more intricate it is likely to be.\nHow many millions of lines of code does it take to make the modern program, web service, car, or airplane possible? The figure below sheds some light on this question.\n\n\n\nThe range is extraordinary: the average iPhone app has less than 50,000 lines of code, while Google’s entire code base is two billion lines for all services. The code needed for fighter jets, popular video game engines, and even the Large Hadron Collider falls somewhere in between the two. It’s been said that the modern smartphone has more lines of code than a passenger jet – and that the code for a typical car has 100 million lines of code.\nIn fact, the lines of code for the Apollo 11 moon lander totaled just 145,000 – and the code for the Space Shuttle was about the same.\nIt’s more than what was needed to run old technologies like the Space Shuttle, a pacemaker, or even the game engine of Quake 3 – but it’s not enough to be the driving force behind the modern software that’s used in everyday life today.\n\nA million lines of code, if printed, would be about 18,000 pages of text. That’s 14x the length of War and Peace.\nHow do we then manage this complexity? A large part of the answer lies in Abstractions. Abstractions are ways of dividing a complex system into smaller, more manageable pieces. Each piece is a black box or module that can be used without having to know how it works internally. However, the pieces are not completely opaque. They have a well-defined interface that allows us to use them without knowing how they work internally.\nOn the other hand, the amount of Data that we have to deal with is growing exponentially. Approximately 328.77 million terabytes of data are created each day.\n\nHere’s a selection of other user-generated internet content stats:\n\n\n\nType of Media\nAmount per Minute\nAmount per Day\n\n\n\n\nEmails sent\n231.4 million\n333.22 billion\n\n\nTexts sent\n16 million\n24.04 billion\n\n\nGoogle searches\n5.9 million\n8.5 billion\n\n\nSnaps shared on Snapchat\n2.43 million\n3.5 billion\n\n\nPieces of content shared on Facebook\n1.7 million\n2.45 billion\n\n\nSwipes on Tinder\n1.1 million\n1.58 billion\n\n\nHours streamed\n1 million\n1.44 billion\n\n\nUSD spent on Amazon\n443,000\n637.92 million\n\n\nUSD sent on Venmo\n437,600\n630.14 million\n\n\nTweets shared on Twitter\n347,200\n499.97 million\n\n\nHours spent in Zoom meetings\n104,600\n150.62 million\n\n\nUSD spent on DoorDash\n76,400\n110.02 million\n\n\n\nFor the software engineer this means writing code that can not only handle the data we have today, but also data that we expect to have in the future. In other words, we need to write code that is scalable.",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#six-problems-of-interest",
    "href": "intro.html#six-problems-of-interest",
    "title": "Introduction",
    "section": "",
    "text": "A LOT of problems in computer science can be ‘reduced’ to a very small set of fundamental problems.\nIn this course, we are going to focus on the six of such fundamental problems.\n\nSearch : Given a set of data, find a particular element in the set\nSort : Given a set of data, arrange the elements in a particular order\n\n3-6. Create, Read, Update, Delete (CRUD)\n\n\nWe are concerned with the process of collecting information in a computer’s memory, in such a way that the information can subsequently be recovered as quickly as possible.\n\nIn this course, we are going to focus on the simplest form of search: searching for a single element in a set of data i.e.  how to find the data that has been stored with a given identification. For example, in a numerical application we might want to find \\(f(x)\\), given \\(x\\) and a table of the values of \\(f\\); in a nonnumerical application, we might want to find the English translation of a given Russian word.\nIn general, we shall suppose that a set of \\(N\\) records has been stored, and the problem is to locate the appropriate one. As in the case of sorting, we assume that each record includes a special field called its key; this terminology is especially appropriate, because many people spend a great deal of time every day searching for their keys. We generally require the \\(N\\) keys to be distinct, so that each key uniquely identifies its record. Algorithms for searching are presented with a so-called argument, \\(q\\), and the problem is to find which record has \\(q\\) as its key.\nAfter the search is complete, two possibilities can arise:\n\nEither the search was successful, having located the unique record containing \\(q\\); or\nIt was unsuccessful, having determined that \\(q\\) is nowhere to be found.\n\nFormally, the search problem is defined as follows:\n\nProblem: \\(\\textbf{Search}\\)\nInput: A set of \\(n\\) keys \\(S\\), and a query key \\(q\\).\nRequired Output: The location of \\(q\\) in \\(S\\), if present, else \\(-1\\).\n\nSearching is the most time-consuming part of many programs, and the substitution of a good search method for a bad one often leads to a substantial increase in speed. In fact we can often arrange the data or the data structure so that searching is eliminated entirely, by ensuring that we always know just where to find the information we need.\nEfficient algorithms for searching turn out to be quite important in practice.\n\n\n\nTypical computer science students study the basic sorting algorithms at least three times before they graduate: first in introductory programming, then in data structures, and finally in an advanced algorithms course.\n\nWhy is sorting worth so much attention? There are several reasons:\n\nSorting is the basic building block that many other algorithms are built around. By understanding sorting, we obtain an amazing amount of power to solve other problems.\nMost of the interesting ideas used in the design of algorithms appear in the context of sorting, such as divide-and-conquer, data structures, and randomized algorithms.\nComputers have historically spent more time sorting than doing anything else. Research shows that a quarter of all computer cycles were spent sorting data [Knu98]. Sorting remains the most ubiquitous combinatorial algorithm problem in practice.\nSorting is the most thoroughly studied problem in computer science. Literally dozens of different algorithms are known, most of which possess some particular advantage over all other algorithms in certain situations.\n\nFormally, the sorting problem is defined as follows:\n\nProblem: \\(\\textbf{Sorting}\\)\nInput: A sequence of \\(n\\) numbers \\(a_1, a_2, \\dots, a_n\\).\nRequired Output: A permutation (reordering) \\(a_1', a_2', \\dots, a_n'\\) of the input sequence such that \\(a_1' \\leq a_2' \\leq \\dots \\leq a_n'\\).\n\nIn this course, we will discuss sorting in reasonable detail, stressing how sorting can be applied to solving other problems. We will also also sorting as a way to introduce paradigms of algorithm design and analysis.\n\n\n\nCreate: Adding a record to a database, inserting a node into a linked list, and inserting an element into a priority queue are all examples of the insert problem. Other names of this problem include: Insert, Add, Post\n\nRead: Reading or accessing data is the most fundamental problem in computer science. Other names of this problem include: Access, Get, Fetch, Retrieve\nUpdate: For each of the following problems, we are given a set of N records, each record containing a key and some associated data, and we are given a particular key K. The problem is to modify the record containing K in some way. Other names of this problem include: Modify, Edit, Patch\nDelete: Deleting a record from a database, deleting a node from a linked list, and deleting an element from a priority queue are all examples of the delete problem. Other names of this problem include: Remove, Drop",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#non-linear-data-structures",
    "href": "intro.html#non-linear-data-structures",
    "title": "Introduction",
    "section": "",
    "text": "In this course, we will also study non-linear data structures.\nNon-linear data structures are those in which each data element can connect to more than two other data elements.\nExamples of non-linear data structures include trees and graphs.\nTrees are a special type of graph, and have a hierarchical structure. Trees are used to represent the hierarchical relationships between data elements.\nExamples of applications of trees in computer science include the representation of file systems and the structure of many data formats such as JSON, XML and HTML.\n\n   \n\nGraphs are used to represent relationships between data elements that are not hierarchical.\nExamples of applications of graphs in computer science include the representation of social networks, the representation of the internet, and the representation of the structure of a computer network.",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#p-vs.-np",
    "href": "intro.html#p-vs.-np",
    "title": "Introduction",
    "section": "",
    "text": "The P vs. NP problem is one of the seven Millennium Prize Problems. It asks whether every problem whose solution can be quickly verified by a computer can also be quickly solved by a computer.\n\n\n\nThe P vs. NP problem is one of the most important unsolved problems in computer science. It is also one of the most famous problems in computer science.\nThe P vs. NP problem is important because it has many practical implications. If P = NP, then many problems that are currently thought to be hard would become easy. For example, many problems in cryptography would become easy to solve.\n\n\n\nThe P problems are the problems that can be solved in polynomial time.\nThe NP problems are the problems that can be verified in polynomial time but as of yet, cannot be solved in polynomial time.\n\n\nThe traveling salesman problem is a problem in combinatorial optimization. It asks for the shortest possible route that visits each city exactly once and returns to the starting city.\n\n\n\nThe traveling salesman problem is one of the most important problems in computer science. It is used in many applications, such as vehicle routing, logistics, and manufacturing.\nOther famous NP-complete problems include the Traveling Salesman Problem, the Knapsack Problem, and the Graph Coloring Problem.",
    "crumbs": [
      "Home",
      "Introduction"
    ]
  },
  {
    "objectID": "ta.html",
    "href": "ta.html",
    "title": "TA",
    "section": "",
    "text": "TA\nFlynn Nisbet is the TA for the class this semester.\nHis office hours are: Monday 7 - 10 PM in Riley 203."
  },
  {
    "objectID": "syllabus/github.html",
    "href": "syllabus/github.html",
    "title": "Github Classroom",
    "section": "",
    "text": "Link to CSC-223 Github Classroom"
  },
  {
    "objectID": "syllabus/appointment.html",
    "href": "syllabus/appointment.html",
    "title": "Appointment",
    "section": "",
    "text": "Appointment\nI don’t have fixed office hours this semester. Instead, I am using an appointment scheduling system Calendly to make it easier for you to find a time that works for you.\nYou can schedule an appointment with me using using this link\nI also have an Open-door Policy and am generally in my office (Riley Hall 200-H) from 10 AM - 4 PM on most weekdays. You are always welcome to drop by and chat.\nI am also ofcourse available via email."
  },
  {
    "objectID": "syllabus/mental_health.html",
    "href": "syllabus/mental_health.html",
    "title": "Mental Health Resources",
    "section": "",
    "text": "Empowering and equipping students to manage their mental health and academic success, the Counseling Center’s stepped care model offers an array of evidence based services.\nThe resources listed below are free, confidential and accessible to all enrolled students. Go to the Counseling Center Website for details.\n\n\nFurman University Counseling Center Mental Health and Crisis Support Line – Call the Counseling Center at 864-294-3031, press #3 (confidential, available 24/7/365 from anywhere).\n\n\n\n\nHeadspace – a mindfulness app that helps decrease stress and improve focus and mind-wandering, sponsored by SGA and PHOKUS. Students may enroll using their Furman email.\nTAO Connect – a self-help platform (anonymous and confidential, 24/7) sponsored by the Counseling Center and accessible to students, faculty and staff. Enroll with a Furman email.\n\n\n\n\n\nPaladin Peer Support is a student peer mentoring organization focused on wellness and self-efficacy. Follow them on Instagram and connect for support in reaching personal well-being goals. ### Skill Building Groups and Workshops\nRotating evidence-based psycho-education and skill building groups for anxiety and emotional regulation ### Consultation and Treatment Services\nStart Strong and Finish Strong Walk-in Clinics (first and last two weeks of every semester)\nBrief individual counseling (in person and online), which may include psychiatric and nutrition consults where clinically indicated.\nSingle Session Consultations\nGroup Counseling and Skill Building Workshops\n\n\n\n\n\n\nThe Office for Spiritual Life provides individual confidential counseling for students, faculty and staff in person and online\nGroups and workshops that are theme-focused and interpersonal\nContact OSL@furman.edu, 864-294-2133, or contact a chaplain directly: vaughn.crowetipton@furman.edu, kate.taber@furman.edu.",
    "crumbs": [
      "Mental Health Resources"
    ]
  },
  {
    "objectID": "syllabus/mental_health.html#the-counseling-center",
    "href": "syllabus/mental_health.html#the-counseling-center",
    "title": "Mental Health Resources",
    "section": "",
    "text": "Empowering and equipping students to manage their mental health and academic success, the Counseling Center’s stepped care model offers an array of evidence based services.\nThe resources listed below are free, confidential and accessible to all enrolled students. Go to the Counseling Center Website for details.\n\n\nFurman University Counseling Center Mental Health and Crisis Support Line – Call the Counseling Center at 864-294-3031, press #3 (confidential, available 24/7/365 from anywhere).\n\n\n\n\nHeadspace – a mindfulness app that helps decrease stress and improve focus and mind-wandering, sponsored by SGA and PHOKUS. Students may enroll using their Furman email.\nTAO Connect – a self-help platform (anonymous and confidential, 24/7) sponsored by the Counseling Center and accessible to students, faculty and staff. Enroll with a Furman email.\n\n\n\n\n\nPaladin Peer Support is a student peer mentoring organization focused on wellness and self-efficacy. Follow them on Instagram and connect for support in reaching personal well-being goals. ### Skill Building Groups and Workshops\nRotating evidence-based psycho-education and skill building groups for anxiety and emotional regulation ### Consultation and Treatment Services\nStart Strong and Finish Strong Walk-in Clinics (first and last two weeks of every semester)\nBrief individual counseling (in person and online), which may include psychiatric and nutrition consults where clinically indicated.\nSingle Session Consultations\nGroup Counseling and Skill Building Workshops",
    "crumbs": [
      "Mental Health Resources"
    ]
  },
  {
    "objectID": "syllabus/mental_health.html#spiritual-life",
    "href": "syllabus/mental_health.html#spiritual-life",
    "title": "Mental Health Resources",
    "section": "",
    "text": "The Office for Spiritual Life provides individual confidential counseling for students, faculty and staff in person and online\nGroups and workshops that are theme-focused and interpersonal\nContact OSL@furman.edu, 864-294-2133, or contact a chaplain directly: vaughn.crowetipton@furman.edu, kate.taber@furman.edu.",
    "crumbs": [
      "Mental Health Resources"
    ]
  },
  {
    "objectID": "syllabus/textbook.html",
    "href": "syllabus/textbook.html",
    "title": "Textbooks & Other Resources",
    "section": "",
    "text": "Caution\n\n\n\nPlease note that the following textbooks are NOT strictly required for this course, but they are strongly recommended for those who prefer to have a physical reference.",
    "crumbs": [
      "Textbooks & Other Resources"
    ]
  },
  {
    "objectID": "syllabus/textbook.html#other-resources",
    "href": "syllabus/textbook.html#other-resources",
    "title": "Textbooks & Other Resources",
    "section": "Other Resources",
    "text": "Other Resources\n\nVisualization and Animation\n\nVisuAlgo (website)\nSorting Algorithms Animations (website)\nData Structure Visualizations (website)\nSorting Algorithms Visualizations, Clément Mihailescu (YouTube video)\nSorting Algorithms Visualizations, Mike Bostock (website)\n\n\n\nBooks\n\nComposing Programs by John DeNero (free, open textbook)\nThink Python by Allen B. Downey (free, open textbook)\n\n\n\nVideo Course\n\nAlgorithms and Data Structures Tutorial - Full Course for Beginners, freeCodeCamp.org (YouTube video)\nData Structures and Algorithms in Python - Full Course for Beginners, freeCodeCamp.org (YouTube video)\nAlgorithms by Jeff Erickson (free, open textbook)\n\n\n\nWebsites\n\nData Structures and Algorithms, Geeks for Geeks (website)\nBig-O Cheat Sheet (website)\n\n\n\nProblems for Practice\n\nProject Euler (website)\nLeetCode (website)\nProject Rosalind (website)",
    "crumbs": [
      "Textbooks & Other Resources"
    ]
  },
  {
    "objectID": "syllabus/textbook.html#other-advanced-textbooks",
    "href": "syllabus/textbook.html#other-advanced-textbooks",
    "title": "Textbooks & Other Resources",
    "section": "Other (Advanced) Textbooks",
    "text": "Other (Advanced) Textbooks\n\nAlgorithms by Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani\nStructure and Interpretation of Computer Programs by Harold Abelson and Gerald Jay Sussman\nAlgorithm Design Manual by Steven Skiena\nAlgorithm Design by Jon Kleinberg and Eva Tardos",
    "crumbs": [
      "Textbooks & Other Resources"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "CSC-122: Introduction to Computer Science"
  },
  {
    "objectID": "syllabus.html#pre-requisites",
    "href": "syllabus.html#pre-requisites",
    "title": "Syllabus",
    "section": "",
    "text": "CSC-122: Introduction to Computer Science"
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Testing in Java",
    "section": "",
    "text": "Testing in Java is a crucial part of the development process. It helps to ensure that the code is working as expected and that any changes made to the code do not introduce new bugs. In this section, we will discuss the basics of testing in Java, including unit testing, integration testing, and test-driven development.",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Testing in Java"
    ]
  },
  {
    "objectID": "test.html#unit-testing",
    "href": "test.html#unit-testing",
    "title": "Testing in Java",
    "section": "Unit Testing",
    "text": "Unit Testing\nUnit testing is a software testing technique where individual units or components of a software application are tested in isolation. The goal of unit testing is to validate that each unit of the software performs as expected. In Java, unit testing is commonly done using the JUnit framework.\n\nJUnit Framework\nJUnit is a popular testing framework for Java that provides annotations and assertions to write and run unit tests. JUnit tests are written as methods in a test class and are executed by a test runner. Here is an example of a simple JUnit test class:\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testSubtraction() {\n        Calculator calculator = new Calculator();\n        int result = calculator.subtract(5, 3);\n        assertEquals(2, result);\n    }\n}\nIn the above example, we have a test class CalculatorTest that contains two test methods testAddition and testSubtraction. Each test method creates an instance of the Calculator class, calls a method on it, and asserts that the result is as expected using the assertEquals method.\nThe name of the test class should end with Test, and the test methods should be annotated with @Test. The assertEquals method is used to compare the expected result with the actual result.\n\n\nRunning Tests\nTo run JUnit tests in Java, you can use an IDE that supports JUnit, such as IntelliJ IDEA or Eclipse. You can also run tests from the command line using the java command with the JUnit platform launcher. Here is an example of running JUnit tests from the command line:\njava -jar junit-platform-console-standalone-1.8.2.jar --class-path target/test-classes --scan-class-path\nIn the above command, junit-platform-console-standalone-1.8.2.jar is the JUnit platform launcher JAR file, target/test-classes is the directory containing the compiled test classes, and --scan-class-path tells",
    "crumbs": [
      "Home",
      "PROGRAMMING, IN JAVA",
      "Operations",
      "Testing in Java"
    ]
  }
]